Artificial Intelligence 121 (2000) 109–169ConGolog, a concurrent programming languagebased on the situation calculusGiuseppe De Giacomo a;(cid:3), Yves Lespérance b, Hector J. Levesque ca Dipartimento di Informatica e Sistemistica, Università di Roma “La Sapienza”, Via Salaria 113,00198 Roma, Italyb Department of Computer Science, York University, Toronto, ON, Canada M3J 1P3c Department of Computer Science, University of Toronto, Toronto, ON, Canada M5S 3H5Received 16 September 1999AbstractAs an alternative to planning, an approach to high-level agent control based on concurrent programexecution is considered. A formal definition in the situation calculus of such a programming languageis presented and illustrated with some examples. The language includes facilities for prioritizing theexecution of concurrent processes, interrupting the execution when certain conditions become true,and dealing with exogenous actions. The language differs from other procedural formalisms forconcurrency in that the initial state can be incompletely specified and the primitive actions can beuser-defined by axioms in the situation calculus. Some mathematical properties of the language areproven, for instance, that the proposed semantics is equivalent to that given earlier for the portion ofthe language without concurrency. (cid:211) 2000 Elsevier Science B.V. All rights reserved.Keywords: Cognitive robotics; Reasoning about actions; Situation calculus; Semantics of programs;Concurrency1. IntroductionWhen it comes to providing high-level control for robots or other agents in dynamicand incompletely known worlds, approaches based on plan synthesis may end up beingtoo demanding computationally in all but simple settings. An alternative approach that isshowing promise is that of high-level program execution [20]. The idea, roughly, is that(cid:3)Corresponding author.E-mail addresses: degiacomo@dis.uniroma1.it (G. De Giacomo), lesperan@cs.yorku.ca (Y. Lespérance),hector@cs.toronto.edu (H.J. Levesque).0004-3702/00/$ – see front matter (cid:211)PII: S 0 0 0 4 - 3 7 0 2 ( 0 0 ) 0 0 0 3 1 - X2000 Elsevier Science B.V. All rights reserved.110G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169instead of searching for a sequence of actions that would take the agent from an initialstate to some goal state, the task is to find a sequence of actions that constitutes a legalexecution of some high-level nondeterministic program. As in planning, to find a sequencethat constitutes a legal execution of a high-level program, it is necessary to reason aboutthe preconditions and effects of the actions within the body of the program. However,if the program happens to be almost deterministic, very little searching is required; asmore and more nondeterminism is included, the search task begins to resemble traditionalplanning. Thus, in formulating a high-level program, the user gets to control the searcheffort required.The hope is that in many domains, what an agent needs to do can be convenientlyexpressed using a suitably rich high-level programming language, and that at the sametime finding a legal execution of that program will be more feasible computationally thanthe corresponding planning task. Previous work on the Golog language [20] consideredhow to reason about actions in programs containing conditionals, iteration, recursion, andnondeterministic operators, where the primitive actions and fluents where characterizedby axioms of the situation calculus. In this paper, we explore how to execute programsincorporating a rich account of concurrency. The execution task remains the same; whatchanges is that the programming language, which we call ConGolog (for ConcurrentGolog) [6], becomes considerably more expressive. One of the nice features of thislanguage is that it allows us to conveniently formulate agent controllers that pursuegoal-oriented tasks while concurrently monitoring and reacting to conditions in theirenvironment, all defined precisely in the language of the situation calculus. But thiskind of expressiveness requires considerable mathematical machinery: we need to encodeConGolog programs as terms in the situation calculus (which, among other things, requiresencoding certain formulas as terms), and we also need to use second-order quantificationto deal with iteration and recursive procedures. It is not at all obvious that such complexdefinitions are well-behaved or even consistent.Of course ours is not the first formal model of concurrency. In fact, well developedapproaches are available [4,17,25,39] 1 and our work inherits many of the intuitionsbehind them. However, it is distinguished from these in at least two fundamental ways.First, it allows incomplete information about the environment surrounding the program. Incontrast to typical computer programs, the initial state of a ConGolog program need onlybe partially specified by a collection of axioms. Second, it allows the primitive actions(elementary instructions) to affect the environment in a complex way and such changes tothe environment can affect the execution of the remainder of the program. In contrast totypical computer programs whose elementary instructions are simple predefined statements(e.g., variable assignments), the primitive actions of a ConGolog program are determinedby a separate domain-dependent action theory, which specifies the action preconditionsand effects, and deals with the frame problem. Finally, it might also be noted that theinteraction between prioritized concurrency and recursive procedures presents a level ofprocedural complexity which, as far as we know, has not been dealt with in any previousformal model.1 In [5,28] a direct use of such approaches to model concurrent (complex) actions in AI is investigated.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169111The rest of the paper is organized as follows: in Section 2 we briefly review the situationcalculus and how it can be used to formulate the planning task. In Section 3, we reviewthe Golog programming language and in the following section, we present a variant of theoriginal specification of the high-level execution task. In Section 5, we explain informallythe sort of concurrency we are concerned with, as well as related notions of prioritiesand interrupts. The section concludes with changes to the Golog specification requiredto handle concurrency. In Section 6, we illustrate the use of ConGolog by going overseveral example programs. Then, in Section 7, we extend such a specification to handleprocedures and recursion. Handling the interaction between the very general form ofprioritized concurrency allowed in ConGolog and recursive procedures will require a quitesophisticated approach. In Section 8 we will show general sufficient conditions that allowus to use a much simplified semantics without loss of generality. In Section 9, we present aProlog interpreter for ConGolog and prove its correctness. In Section 10, we conclude bydiscussing some of the properties of ConGolog, its implementation, and topics for futureresearch.2. The situation calculusAs mentioned earlier, our high-level programs contain primitive actions and tests that aredomain dependent. An interpreter for such programs must reason about the preconditionsand effects of actions in the program to find legal executions. So we need a language tospecify such domain theories. For this, we use the situation calculus [24], a first-orderlanguage (with some second-order features) for representing dynamic domains. In thisformalism, all changes to the world are the result of named actions. A possible worldhistory, which is simply a sequence of actions, is represented by a first-order term calleda situation. The constant S0 is used to denote the initial situation, namely that situationin which no actions have yet occurred. There is a distinguished binary function symboldo and the term do.a; s/ denotes the situation resulting from action a being performedin situation s. Actions may be parameterized. For example, put.x; y/ might stand for theaction of putting object x on object y, in which case do.put.A; B/; s/ denotes that situationresulting from putting A on B when the world is in situation s. Notice that in the situationcalculus, actions are denoted by function symbols, and situations (world histories) are alsofirst-order terms. For example,do.putDown.A/; do.walk.P /; do.pickUp.A/; S0///is a situation denoting the world history consisting of the sequence of actionsTpickUp.A/; walk.P /; putDown.A/U:Relations whose truth values vary from situation to situation, called relational fluents,are denoted by predicate symbols taking a situation term as their last argument. Forexample, Holding.r; x; s/ might mean that a robot r is holding an object x in situation s.Functions whose denotations vary from situation to situation are called functional fluents.They are denoted by function symbols with an additional situation argument, as inposition.r; s/, i.e., the position of robot r in situation s.112G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169The actions in a domain are specified by providing certain types of axioms. First, onemust state the conditions under which it is physically possible to perform an action byproviding a action precondition axiom. For this, we use the special predicate Poss.a; s/which represents the fact that primitive action a is physically possible (i.e., executable) insituation s. So, for example,Poss.pickup.x/; s/ (cid:17) 8x::Holding.x; s/ ^ NextTo.x; s/ ^ :Heavy.x/says that the action pickup.x/, i.e., the agent picking up an object x, is possible in situations if and only if the agent is not already holding something in situation s and is positionednext to x in s and x is not heavy.Secondly, one must specify how the action affects the state of the world; this is done byproviding effect axioms. For example,Fragile.x; s/ (cid:27) Broken.x; do.drop.x; s///says that dropping an object x causes it to become broken provided that x is fragile. Effectaxioms provide the “causal laws” for the domain of application.These types of axioms are usually insufficient if one wants to reason about change.One must add frame axioms that specify when fluents remain unchanged by actions. Forexample, dropping an object does not affect the color of things:colour.y; s/ D c (cid:27) colour.y; do.drop.x; s/// D c:The frame problem arises because the number of these frame axioms is very large, ingeneral, of the order of 2 (cid:2) A (cid:2) F , where A is the number of actions and F the number offluents. This complicates the task of axiomatizing a domain and can make theorem provingextremely inefficient.To deal with the frame problem, we use an approach due to Reiter [31]. The basic ideabehind this is to collect all effect axioms about a given fluent and make a completenessassumption, i.e., assume that they specify all of the ways that the value of the fluent maychange. A syntactic transformation can then be applied to obtain a successor state axiomfor the fluent, for example:Broken.x; do.a; s// (cid:17)a D drop.x/ ^ Fragile.x; s/ _9b:.a D explode.b/ ^ NextTo.b; x; s// _Broken.x; s/ ^ a 6D repair.x/:This says that an object x is broken in the situation resulting from action a being performedin s if and only if a is dropping x and x is fragile, or a involves a bomb exploding nextto x, or x was already broken in situation s prior to the action and a is not the actionof repairing x. This approach yields a solution to the frame problem—a parsimoniousrepresentation for the effects of actions. Note that it relies on quantification over actions.This discussion ignores the ramification and qualification problems; a treatment compatiblewith the approach described has been proposed by Lin and Reiter [21].So following this approach, a domain of application will be specified by a theory of thefollowing form:G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169113(cid:15) Axioms describing the initial situation, S0.(cid:15) Action precondition axioms, one for each primitive action a, characterizing Poss.a; s/.(cid:15) Successor state axioms, one for each fluent F , stating under what conditionsF .Ex; do.a; s// holds as function of what holds in situation s:(cid:15) Unique names axioms for the primitive actions.(cid:15) Some foundational, domain independent axioms.The latter foundational axioms include unique names axioms for situations, and aninduction axiom. They also introduce the relation < over situations. s < s0 holds if andonly if s0 is the result of some sequence of actions being performed in s, where eachaction in the sequence is possible in the situation in which it is performed; s 6 s0 standsfor s < s0 _ s D s0. Since the foundational axioms play no special role in this paper, weomit them. For details, and for some of their metamathematical properties, see Lin andReiter [21] and Reiter [32].For any domain theory of the sort just described, we have a very clean specification ofthe planning task, which dates back to the work of Green [13]:Classical Planning. Given a domain theory D as above, and a goal formula (cid:30).s/ with asingle free-variable s; the planning task is to find a sequence of actions Ea such that:D jD Legal.Ea; S0/ ^ (cid:30).do.Ea; S0//;where do.Ta1; : : : ; anU; s/ is an abbreviation fordo.an; do.an(cid:0)1; : : : ; do.a1; s/ : : ://;and where Legal.Ta1; : : : ; anU; s/ stands forPoss.a1; s/ ^ (cid:1) (cid:1) (cid:1) ^ Poss.an; do.Ta1; : : : ; an(cid:0)1U; s//:In other words, the task is to find a sequence of actions that is executable (each actionis executed in a context where its precondition is satisfied) and that achieves the goal (thegoal formula (cid:30) holds in the final state that results from performing the actions in sequence).3. GologAs presented in [20], Golog is a logic-programming language whose primitive actionsare those of a background domain theory. It includes the following constructs ((cid:14), possiblysubscripted, ranges over Golog programs):a,(cid:30)?,.(cid:14)1I (cid:14)2/,.(cid:14)1 j (cid:14)2/,(cid:25)v:(cid:14),primitive actionwait for a condition 2sequencenondeterministic choice between actionsnondeterministic choice of arguments2 Because there are no exogenous actions or concurrent processes in Golog, waiting for (cid:30) amounts to testingthat (cid:30) holds in the current state.114G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169(cid:14)(cid:3),fproc P1.Ev1/ (cid:14)1 endI : : : proc Pn.Evn/ (cid:14)n endI (cid:14)g,nondeterministic iterationprocedures.In the first line, a stands for a situation calculus action where the special situation constantnow may be used to refer to the current situation (i.e., that where a is to be executed).Similarly, in the line below, (cid:30) stands for a situation calculus formula where now maybe used to refer to the current situation, for example OnTable.block; now/. aTsU ((cid:30)TsU)will denote the action (formula) obtained by substituting the situation variable s forall occurrences of now in functional fluents appearing in a (functional and predicatefluents appearing in (cid:30)). Moreover when no confusion can arise, we often leave outthe now argument from fluents altogether; for example, write OnTable.block/ insteadof OnTable.block; now/. In such cases, the situation suppressed version of the action orformula should be understood as an abbreviation for the version with now.Let’s examine a simple example to see some of the features of the language. Here’s aGolog program to clear the table in a blocks world:(cid:25)b: TOnTable.b; now/?I pickUp.b/I putAway.b/U(cid:8)proc removeAblockendIremoveAblock:9b: OnTable.b; now/?(cid:3)I(cid:9):Here we first define a procedure to remove a block from the table using the nondeter-ministic choice of argument operator (cid:25) . (cid:25)x: T(cid:14).x/U is executed by nondeterministicallypicking an individual x, and for that x, performing the program (cid:14).x/. The wait actionOnTable.b; now/? succeeds only if the individual chosen, b, is a block that is on the tablein the current situation. The main part of the program uses the nondeterministic iterationoperator; it simply says to execute removeAblock zero or more times until the table is clear.Note that Golog’s other nondeterministic construct, .(cid:14)1 j (cid:14)2/, allows a choice between twoactions; a program of this form can be executed by performing either (cid:14)1 or (cid:14)2.In its most basic form, the high-level program execution task is a special case of theabove planning task:Program Execution. Given a domain theory D as above, and a program (cid:14), the executiontask is to find a sequence of actions Ea such that:D jD Do.(cid:14); S0; do.Ea; S0//;where Do.(cid:14); s; s0/ means that program (cid:14) when executed starting in situation s has s0 as alegal terminating situation.Note that since Golog programs can be nondeterministic,terminating situations for the same program and starting situation.there may be severalIn [20], Do.(cid:14); s; s0/ was simply viewed as an abbreviation for a formula of the situationcalculus. The following inductive definition of Do was provided:(1) Primitive actions:Do.a; s; s0/defD Poss.aTsU; s/ ^ s0 D do.aTsU; s/:G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169115(2) Wait/test actions:Do.(cid:30)?; s; s0/defD (cid:30)TsU ^ s D s0:(3) Sequence:Do.(cid:14)1I (cid:14)2; s; s0/defD 9s00: Do.(cid:14)1; s; s00/ ^ Do.(cid:14)2; s00; s0/:(4) Nondeterministic branch:Do.(cid:14)1 j (cid:14)2; s; s0/defD Do.(cid:14)1; s; s0/ _ Do.(cid:14)2; s; s0/:(5) Nondeterministic choice of argument:Do.(cid:25)x:(cid:14).x/; s; s0/defD 9x: Do.(cid:14).x/; s; s0/:(6) Nondeterministic iteration:Do.(cid:14)(cid:3); s; s0/defD 8P :(cid:8)(cid:9)8s1: P .s1; s1/ ^8s1; s2; s3:TP .s1; s2/ ^ Do.(cid:14); s2; s3/ (cid:27) P .s1; s3/U(cid:27) P .s; s0/:In other words, doing action (cid:14) zero or more times takes you from s to s0 if and onlyif .s; s0/ is in every set (and therefore, the smallest set) such that:(a) .s1; s1/ is in the set for all situations s1.(b) Whenever .s1; s2/ is in the set, and doing (cid:14) in situation s2 takes you to situations3, then .s1; s3/ is in the set.The above definition of nondeterministic iteration is the standard second-order wayof expressing this set. Some appeal to second-order logic appears necessary herebecause transitive closure is not first-order definable, and nondeterministic iterationappeals to this closure.We have left out the expansion for procedures, which is somewhat more complex; see [20]for the details.4. A transition semanticsBy using Do, programs are assigned a semantics in terms of a relation, denoted bythe formulas Do.(cid:14); s; s0/, that given a program (cid:14) and a situation s, returns a situation s0resulting from executing the program starting in the situation s. Semantics of this formare sometimes called evaluation semantics (see [15,26]), since they are based on the(complete) evaluation the program.When concurrency is taken into account it is more convenient to adopt semantics of adifferent form: the so-called transition semantics or computation semantics (see again [15,26]). Transition semantics are based on defining single steps of computation in contrast todirectly defining complete computations.In the present case, we are going to define a relation, denoted by the predicateTrans.(cid:14); s; (cid:14)0; s0/, that associates to a given program (cid:14) and situation s, a new situation116G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169s0 that results from executing a primitive action or test action and a new program (cid:14)0 thatrepresents what remains of the program after having performed such an action. In otherwords, Trans denotes a transition relation between configurations. A configuration is apair formed by a program (the part of the initial program that is left to perform) and the asituation (representing the current situation).We are also going to introduce a predicate Final.(cid:14); s/, meaning that the configuration.(cid:14); s/ is a final one, that is, where the computation can be considered completed (noprogram remains to be executed). The final situations reached after a finite numberof transitions from a starting situation coincide with those satisfying the Do relation.Complete computations are thus defined by repeatedly composing single transitions untila final configuration is reached.It worth noting that if a program does not terminate, then no final situation will satisfythe Do relation (indeed evaluation semantics are typically used for terminating programs),while we can still keep track of the various transitions performed by means of Trans.Indeed, nonterminating programs do not need any special treatment within transitionsemantics, while they typically remain undefined in evaluation semantics.In general, both evaluation semantics and transition semantics belong to the family ofstructural operational semantics introduced by Plotkin in [27]. Both of these forms ofsemantics are operational since they do not assign a meaning directly to the programs (asdenotational semantics), but instead see programs simply as specifications of computations(or better as syntactic objects that specify the control flow of the computation). They areabstract semantics since, in contrast to concrete operational semantics, they do not define aspecific machine on which the operations are performed, but instead only define an abstractrelation (such as Do or Trans) which denotes the possible computations (either completecomputations for evaluation semantics, or single steps of computations for transitionsemantics). In addition, both such form of semantics are structural since are are definedon the structure of the programs.4.1. Encoding programs as first-order termsIn the simple semantics using Do, it was possible to avoid introducing programsexplicitly into the logical language, since Do.(cid:14); s; s0/ was only an abbreviation for aformula (cid:8).s; s0/ that did not mention the program (cid:14) (or any other programs). This waspossible essentially because it was not necessary to quantify over programs.Basing the semantics on Trans however does require quantification over programs. Toallow for this, we develop an encoding of programs as first-order terms in the logicallanguage (observe that programs as such, cannot in general be first-order terms, since onone hand, they mention formulas in tests, and on the other, the operator (cid:25) in (cid:25)x:(cid:14) is aquantifier).Encoding programs as first-order terms, although it requires some care (e.g., introducingconstants denoting variables and defining substitution explicitly in the language), does notpose any major problem. 3 In the following we abstract from the details of the encoding3 Observe that, we assume that formulas that occur in tests never mention programs, so it is impossible to buildself-referential sentences.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169117as much as possible, and essentially use programs within formulas as if they were alreadyfirst-order terms. The full encoding is given in Appendix A.4.2. Trans and FinalLet us formally define Trans and Final, which intuitively specify what are the possibletransitions between configurations (Trans), and when a configuration can be consideredfinal (Final).It is convenient to introduce a special program nil, called the empty program, to denotethe fact that nothing remains to be performed (legal termination). For example, consider aprogram consisting solely of a primitive action a. If it can be executed (i.e., if the action ispossible in the current situation), then after the execution of the action a nothing remains ofthe program. In this case, we say that the program remaining after the execution of actiona is nil.Trans.(cid:14); s; (cid:14)0; s0/ holds if and only if there is a transition from the configuration .(cid:14); s/to the the configuration .(cid:14)0; s0/, that is, if by running program (cid:14) starting in situation s, onecan get to situation s0 in one elementary step with the program (cid:14)0 remaining to be executed.As mentioned, every such elementary step will either be the execution of an atomic action(which changes the current situation) or the execution of a test (which does not). As well,if the program is nondeterministic, there may be several transitions that are possible in aconfiguration. To simplify the discussion, we postpone the introduction of procedures toSection 7.The predicate Trans for programs without procedures is characterized by the followingset of axioms T (here as in the rest of the paper, free variables are assumed to be universallyquantified):(1) Empty program:Trans.nil; s; (cid:14)0; s0/ (cid:17) False:(2) Primitive actions:Trans.a; s; (cid:14)0; s0/ (cid:17)Poss.aTsU; s/ ^ (cid:14)0 D nil ^ s0 D do.aTsU; s/:(3) Wait/test actions:Trans.(cid:30)?; s; (cid:14)0; s0/ (cid:17) (cid:30)TsU ^ (cid:14)0 D nil ^ s0 D s:(4) Sequence:Trans.(cid:14)1I (cid:14)2; s; (cid:14)0; s0/ (cid:17)9(cid:13) :(cid:14)0 D .(cid:13) I (cid:14)2/ ^ Trans.(cid:14)1; s; (cid:13) ; s0/ _Final.(cid:14)1; s/ ^ Trans.(cid:14)2; s; (cid:14); s/:00(5) Nondeterministic branch:Trans.(cid:14)1 j (cid:14)2; s; (cid:14)0/ (cid:17)Trans.(cid:14)1; s; (cid:14)0; s0/ _ Trans.(cid:14)2; s; (cid:14)0; s0/:; s0118G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169(6) Nondeterministic choice of argument:Trans.(cid:25)v:(cid:14); s; (cid:14)0; s0/ (cid:17) 9x:Trans.(cid:14)vx ; s; (cid:14)0; s0/:(7) Iteration:Trans.(cid:14)(cid:3); s; (cid:14)0; s0/ (cid:17)9(cid:13) :.(cid:14)0 D (cid:13) I (cid:14)(cid:3)/ ^ Trans.(cid:14); s; (cid:13) ; s0/:The assertions above characterize when a configuration .(cid:14); s/ can evolve (in a singlestep) to a configuration .(cid:14)0; s0/. Intuitively they can be read as follows:(1) .nil; s/ cannot evolve to any configuration.(2) .a; s/ evolves to .nil; do.aTsU; s//, provided that aTsU is possible in s. After havingperformed a, nothing remains to be performed and hence nil is returned. Note thatin Trans.a; s; (cid:14)0; s0/, a stands for the program term encoding the correspondingsituation calculus action, while Poss and do take the latter as argument; we takethe function (cid:1)T(cid:1)U as mapping the program term a into the corresponding situationcalculus action aTsU, as well as replacing now by the situation s. The details of howthis function is defined are in Appendix A.(3) .(cid:30)?; s/ evolves to .nil; s/, provided that (cid:30)TsU holds, otherwise it cannot proceed.Note that the situation remains unchanged. Analogously to the previous case,we take the function (cid:1)T(cid:1)U as mapping the program term for condition (cid:30) into thecorresponding situation calculus formulas (cid:30)TsU, as well as replacing now by thesituation s (see Appendix A for details).(4) .(cid:14)1I (cid:14)2; s/ can evolve to .(cid:14)01Moreover it can also evolve to .(cid:14)02; s0/.and .(cid:14)2; s/ can evolve to .(cid:14)0I (cid:14)2; s0/, provided that .(cid:14)1; s/ can evolve to .(cid:14)01; s0/.2; s0/, provided that .(cid:14)1; s/ is a final configuration(5) .(cid:14)1j(cid:14)2; s/ can evolve to .(cid:14)0; s0/, provided that either .(cid:14)1; s/ or .(cid:14)2; s/ can do so.(6) .(cid:25)v:(cid:14); s/ can evolve to .(cid:14)0; s0/, provided that there exists an x such that .(cid:14)vx ; s/ canx is the program resulting from (cid:14) by substituting v with theevolve to .(cid:14)0; s0/. Here (cid:14)vvariable x. 4(7) .(cid:14)(cid:3); s/ can evolve to .(cid:14)0I (cid:14)(cid:3); s0/ provided that .(cid:14); s/ can evolve to .(cid:14)0; s0/. Observethat .(cid:14)(cid:3); s/ can also not evolve at all, .(cid:14)(cid:3); s/ being final by definition (see below).Final.(cid:14); s/ tells us whether a program (cid:14) can be considered to be already in a final state(legally terminated) in the situation s. Obviously we have Final.nil; s/, but also Final.(cid:14)(cid:3); s/since (cid:14)(cid:3) requires 0 or more repetitions of (cid:14) and so it is possible to not execute (cid:14) at all, theprogram completing immediately.The predicate Final for programs without procedures is characterized by the set ofaxioms F :(1) Empty program:Final.nil; s/ (cid:17) True:(2) Primitive action:Final.a; s/ (cid:17) False:4 To be more precise, v is substituted by a term of the form nameOf.x/, where nameOf is used to convertsituation calculus objects/actions into program terms of the corresponding sort (see Appendix A).G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169119(3) Wait/test action:Final.(cid:30)?; s/ (cid:17) False:(4) Sequence:Final.(cid:14)1I (cid:14)2; s/ (cid:17)Final.(cid:14)1; s/ ^ Final.(cid:14)2; s/:(5) Nondeterministic branch:Final.(cid:14)1 j (cid:14)2; s/ (cid:17)Final.(cid:14)1; s/ _ Final.(cid:14)2; s/:(6) Nondeterministic choice of argument:Final.(cid:25)v:(cid:14); s/ (cid:17) 9x:Final.(cid:14)vx ; s/:(7) Iteration:Final.(cid:14)(cid:3); s/ (cid:17) True:The assertions above can be read as follows:(1) .nil; s/ is a final configuration.(2) .a; s/ is not final, indeed the program consisting of the primitive action a cannot beconsidered completed until it has performed a.(3) .(cid:30)?; s/ is not final, indeed the program consisting of the test action (cid:30)? cannot beconsidered completed until it has performed the test (cid:30)?.(4) .(cid:14)1I (cid:14)2; s/ can be considered completed if both .(cid:14)1; s/ and .(cid:14)2; s/ are final.(5) .(cid:14)1j(cid:14)2; s/ can be considered completed if either .(cid:14)1; s/ or .(cid:14)2; s/ is final.(6) .(cid:25)v:(cid:14); s/ can be considered completed, provided that there exists an x such that.(cid:14)vx ; s/ is final, where (cid:14)vx is obtained from (cid:14) by substituting v with x.(7) .(cid:14)(cid:3); s/ is a final configuration, since by (cid:14)(cid:3) is allowed to execute 0 times.In the following we denote by C be the set of axioms for Trans and Final plus those neededfor the encoding of programs as first-order terms.4.3. Trans(cid:3) and DoThe possible configurations that can be reached by a program (cid:14) starting in a situation sare those obtained by repeatedly following the transition relation denoted by Trans startingfrom .(cid:14); s/, i.e., those in the reflexive transitive closure of the transition relation. Such arelation, denoted by Trans(cid:3), is defined as the (second-order) situation calculus formula:Trans(cid:3).(cid:14); s; (cid:14)0; s0/defD 8T :T: : : (cid:27) T .(cid:14); s; (cid:14)0; s0/U;where : : : stands for the conjunction of the universal closure of the following implications:True (cid:27) T .(cid:14); s; (cid:14); s/;Trans.(cid:14); s; (cid:14)0000/ ^ T .(cid:14)000000; s; (cid:14); s; s/ (cid:27) T .(cid:14); s; (cid:14)00/:; s120G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Using Trans(cid:3) and Final we can give a new definition of Do as:Do.(cid:14); s; s0/defD 9(cid:14)0:Trans(cid:3).(cid:14); s; (cid:14)0; s0/ ^ Final.(cid:14)0; s0/:In other words, Do.(cid:14); s; s0/ holds if it is possible to repeatedly single-step the program (cid:14),obtaining a program (cid:14)0 and a situation s0 such that (cid:14)0 can legally terminate in s0.For Golog programs such a definition for Do coincides with the one given in [20].Formally, we can state the the following result:Theorem 1. Let Do1 be the original definition of Do in [20], presented in Section 3, andDo2 the new one given above. Then for each Golog program (cid:14):C jD 8s; s0: Do1.(cid:14); s; s0/ (cid:17) Do2.(cid:14); s; s0/:Proof. See Appendix B. 2The theorem also holds for Golog programs involving procedures when the treatment inSection 7 is used.Let us note that a Trans-step which brings the state of a computation from one configura-tion .(cid:14); s/ to another .(cid:14)0; s0/ need not change the situation part of the configuration, i.e., wemay have s D s0. In particular, test actions have this property. If we want to abstract fromsuch computation steps that only change the state of the program, we can easily define anew relation, TransSit, that skips transitions that do not change the situation:TransSit.(cid:14); s; (cid:14)0; s/defD 8T 0:T: : : (cid:27) T 0.(cid:14); s; (cid:14)0; s0/U;where : : : stands for the conjunction of the universal closure of the following implications:Trans.(cid:14); s; (cid:14)0; s0/ ^ s0 6D s (cid:27) T 0.(cid:14); s; (cid:14)0; s0/;Trans.(cid:14); s; (cid:14)00; s/ ^ T 0.(cid:14)00; s; (cid:14)0; s0/ (cid:27) T 0.(cid:14); s; (cid:14)0; s0/:5. ConcurrencyWe are now ready to define ConGolog, an extended version of Golog that incorporatesa rich account of concurrency. We say ‘rich’ because it handles:(cid:15) concurrent processes with possibly different priorities,(cid:15) high-level interrupts,(cid:15) arbitrary exogenous actions.As is commonly done in other areas of computer science, we model concurrent processes asinterleavings of the primitive actions in the component processes. A concurrent executionof two processes is one where the primitive actions in both processes occur, interleaved insome fashion. So in fact, we never have more than one primitive action happening at anygiven time. This assumption might appear problematic when the domain involves actionswith extended duration (e.g., filling a bathtub). In Section 6.4, we return to this issue andargue that in fact, there is a straightforward way to handle such cases.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169121An important concept in understanding concurrent execution is that of a processbecoming blocked. If a deterministic process (cid:14) is executing, and reaches a point whereit is about to do a primitive action a in a situation s but where Poss.a; s/ is false (or await action (cid:30)?, where (cid:30)TsU is false), then the overall execution need not fail as in Golog. InConGolog, the current interleaving can continue successfully provided that a process otherthan (cid:14) executes next. The net effect is that (cid:14) is suspended or blocked, and execution mustcontinue elsewhere. 5The ConGolog language is exactly like Golog except with the following additionalconstructs:if (cid:30) then (cid:14)1 else (cid:14)2,while (cid:30) do (cid:14),.(cid:14)1 k (cid:14)2/,.(cid:14)1 ii (cid:14)2/,(cid:14)jj,h(cid:30) ! (cid:14)i,synchronized conditionalsynchronized loopconcurrent executionconcurrency with different prioritiesconcurrent iterationinterrupt.The constructs if (cid:30) then (cid:14)1 else (cid:14)2 and while (cid:30) do (cid:14) are the synchronized versions ofthe usual if-then-else and while-loop. They are synchronized in the sense that testing thecondition (cid:30) does not involve a transition per se: the evaluation of the condition and the firstaction of the branch chosen are executed as an atomic unit. So these constructs behave in asimilar way to the test-and-set atomic instructions used to build semaphores in concurrentprogramming [1]. 6The construct .(cid:14)1 k (cid:14)2/ denotes the concurrent execution of the actions (cid:14)1 and (cid:14)2..(cid:14)1 ii (cid:14)2/ denotes the concurrent execution of the actions (cid:14)1 and (cid:14)2 with (cid:14)1 having higherpriority than (cid:14)2. This restricts the possible interleavings of the two processes: (cid:14)2 executesonly when (cid:14)1 is either done or blocked. The next construct, (cid:14)jj, is like nondeterministiciteration, but where the instances of (cid:14) are executed concurrently rather than in sequence.Just as (cid:14)(cid:3) executes with respect to Do like nil j (cid:14) j .(cid:14)I (cid:14)/ j .(cid:14)I (cid:14)I (cid:14)/ j : : : , the program (cid:14)jjexecutes with respect to Do like nil j (cid:14) j .(cid:14) k (cid:14)/ j .(cid:14) k (cid:14) k (cid:14)/ j : : : . See Section 6.3 for anexample of its use.Finally, h(cid:30) ! (cid:14)i is an interrupt. It has two parts: a trigger condition (cid:30) and a body, (cid:14).The idea is that the body (cid:14) will execute some number of times. If (cid:30) never becomes true,(cid:14) will not execute at all. If the interrupt gets control from higher priority processes when(cid:30) is true, then (cid:14) will execute. Once it has completed its execution, the interrupt is readyto be triggered again. This means that a high priority interrupt can take complete controlof the execution. For example, hTrue ! ringBelli at the highest priority would ring a belland do nothing else. With interrupts, we can easily write controllers that can stop whatever5 Just as actions in Golog are external (e.g., there is no internal variable assignment), in ConGolog, blockingand unblocking also happen externally, via Poss and wait actions. Internal synchronization primitives are easilyadded.6 In [20], nonsynchronized versions ofif-then-else and while-loops are introduced by defining:defD T.(cid:30)?I (cid:14)/(cid:3)I :(cid:30)?U. The synchronizedif (cid:30) then (cid:14)1 else (cid:14)2versions of these constructs introduced here behave essentially as the nonsynchronized ones in absence of con-currency. However the difference is striking when concurrency is allowed.defD T.(cid:30)?I (cid:14)1/ j .:(cid:30)?I (cid:14)2/U and while (cid:30) do (cid:14)122G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169task they are doing to handle various concerns as they arise. They are, dare we say, morereactive.We now show how Trans and Final need to be extended to handle these constructs. (Wehandle interrupts separately below.) Trans and Final for synchronized conditionals andloops are defined as follows:Trans.if (cid:30) then (cid:14)1 else (cid:14)2; s; (cid:14)0; s0/ (cid:17)(cid:30)TsU ^ Trans.(cid:14)1; s; (cid:14)0; s0/ _ :(cid:30)TsU ^ Trans.(cid:14)2; s; (cid:14)0; s0/;/ (cid:17)0 D (cid:13) I while (cid:30) do (cid:14)/ ^ (cid:30)TsU ^ Trans.(cid:14); s; (cid:13) ; sTrans.while (cid:30) do (cid:14); s; (cid:14)9(cid:13) :.(cid:14); s/;000Final.if (cid:30) then (cid:14)1 else (cid:14)2; s/ (cid:17)(cid:30)TsU ^ Final.(cid:14)1; s/ _ :(cid:30)TsU ^ Final.(cid:14)2; s/;Final.while (cid:30) do (cid:14); s/ (cid:17):(cid:30)TsU _ Final.(cid:14); s/:That is .if (cid:30) then (cid:14)1 else (cid:14)2; s/ can evolve to .(cid:14)0; s0/, if either (cid:30)TsU holds and .(cid:14)1; s/ cando so, or :(cid:30)TsU holds and .(cid:14)2; s/ can do so. Similarly, .while (cid:30) do (cid:14); s/ can evolve to.(cid:14)0I while (cid:30) do (cid:14); s0/, if (cid:30)TsU holds and .(cid:14); s/ can evolve to .(cid:14)0; s0/. .if (cid:30) then (cid:14)1 else (cid:14)2; s/can be considered completed, if either (cid:30)TsU holds and .(cid:14)1; s/ is final, or if :(cid:30)TsU holds and.(cid:14)2; s/ is final. Similarly, .while (cid:30) do (cid:14); s/ can be considered completed if either :(cid:30)TsUholds or .(cid:14); s/ is final.For the constructs for concurrency the extension of Final is straightforward:Final.(cid:14)1 k (cid:14)2; s/ (cid:17) Final.(cid:14)1; s/ ^ Final.(cid:14)2; s/;Final.(cid:14)1 ii (cid:14)2; s/ (cid:17) Final.(cid:14)1; s/ ^ Final.(cid:14)2; s/;Final.(cid:14)jj; s/ (cid:17) True:Observe that the last clause says that it is legal to execute the (cid:14) in (cid:14)jj zero times. For Trans,we have the following:Trans.(cid:14)1 k (cid:14)2; s; (cid:14)0; s0/ (cid:17)09(cid:13) :(cid:14)9(cid:13) :(cid:14)0 D .(cid:13) k (cid:14)2/ ^ Trans.(cid:14)1; s; (cid:13) ; s0 D .(cid:14)1 k (cid:13) / ^ Trans.(cid:14)2; s; (cid:13) ; s0/ (cid:17)9(cid:13) :(cid:14)0 D .(cid:13) ii (cid:14)2/ ^ Trans.(cid:14)1; s; (cid:13) ; s0/ _9(cid:13) :(cid:14)0 D .(cid:14)1 ii (cid:13) / ^ Trans.(cid:14)2; s; (cid:13) ; s0/ ^ :9(cid:16); s00: Trans.(cid:14)1; s; (cid:16); s00/;/ _/;Trans.(cid:14)1 ii (cid:14)2; s; (cid:14); s00Trans.(cid:14)jj; s; (cid:14)0; s0/ (cid:17)9(cid:13) :(cid:14)0 D .(cid:13) k (cid:14)jj/ ^ Trans.(cid:14); s; (cid:13) ; s0/:In other words, you single step .(cid:14)1 k (cid:14)2/ by single stepping either (cid:14)1 or (cid:14)2 and leavingthe other process unchanged. The .(cid:14)1 ii (cid:14)2/ construct is identical, except that you are onlyallowed to single step (cid:14)2 if there is no legal step for (cid:14)1. This ensures that (cid:14)1 will executeas long as it is possible for it to do so. Finally, you single step (cid:14)jj by single stepping (cid:14), andG. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169123what is left is the remainder of (cid:14) as well as (cid:14)jj itself. This allows an unbounded number ofinstances of (cid:14) to be running.Observe that with .(cid:14)1 k (cid:14)2/, if both (cid:14)1 and (cid:14)2 are always able to execute, the amountof interleaving between them is left completely open. It is legal to execute one of themcompletely before even starting the other, and it also legal to switch back and forth aftereach primitive or wait action. It is not hard to define, however, new concurrency constructskmin and kmax that require the amount of interleaving to be minimized or maximizedrespectively. We omit the details.Regarding interrupts, it turns out that these can be explained using other constructs ofConGolog:h(cid:30) ! (cid:14)idefD while Interrupts_running doif (cid:30) then (cid:14) else False?To see how this works, first assume that the special fluent Interrupts_running is identicallyTrue. When an interrupt h(cid:30) ! (cid:14)i gets control, it repeatedly executes (cid:14) until (cid:30) becomesfalse, at which point it blocks, releasing control to anyone else able to execute. Notethat according to the above definition of Trans, no transition occurs between the testcondition in a while-loop or an if-then-else and the body. In effect, if (cid:30) becomes false,the process blocks right at the beginning of the loop, until some other action makes (cid:30)true and resumes the loop. To actually terminate the loop, we use a special primitiveaction stop_interrupts, whose only effect is to make Interrupts_running false. Thus, weimagine that to execute a program (cid:14) containing interrupts, we would actually executethe program fstart_interrupts I .(cid:14) ii stop_interrupts/g which has the effect of stopping allblocked interrupt loops in (cid:14) at the lowest priority, i.e., when there are no more actions in (cid:14)that can be executed.Finally, let us consider exogenous actions. These are primitive actions that may occurwithout being part of a user-specified program. We assume that in the background theory,the user declares, using a predicate Exo, which actions can occur exogenously. We definea special program for exogenous events:(cid:14)EXOdefD .(cid:25) a: Exo.a/?I a/(cid:3):Executing this program involves performing zero, one, or more nondeterministicallychosen exogenous events. 7 Then we make the user-specified program (cid:14) run concurrentlywith (cid:14)EXO:(cid:14) k (cid:14)EXO:In this way we allow exogenous actions whose preconditions are satisfied to asynchro-nously occur (outside the control of (cid:14)) during the execution of (cid:14).7 Observe the use of (cid:25) : the program nondeterministically chooses an action a, tests that this a is an exogenousevent, and executes it.124G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–1695.1. Formal properties of Trans and Final without proceduresWe are going to show that the axioms for Trans and Final for the whole of ConGolog aredefinitional, in the sense that they completely characterize Trans and Final for programswithout procedures.Lemma 1. For any ConGolog program term (cid:14).Ex/ containing only variables Ex of sortobject or action, there exist two formulas (cid:8).Ex; s; (cid:14); s0/ and (cid:9) .Ex; s/, where Ex; s; (cid:14)0; s0 andEx; s are the only free variables in (cid:8) and in (cid:9) respectively, that do not mention Final andTrans, and are such that:C jD 8Ex; s; (cid:14)0; s0: Trans.(cid:14).Ex/; s; (cid:14)0; s0/ (cid:17) (cid:8).Ex; s; (cid:14)0; s0/;C jD 8Ex; s: Final.(cid:14).Ex/; s/ (cid:17) (cid:9) .Ex; s/:(1)(2)Proof. For both (1) and (2), the proof is similar; it is done by induction on the programstructure considering as base cases programs of the form nil, a, and (cid:30)?. Base cases: thethesis is an immediate consequence of the axioms of Trans and Final since the right-handside of the equivalences does not mention Trans and Final. Inductive cases: by inspection,all the axioms have on the right-hand side simpler program terms, which contain onlyvariables of sort object or action, as the first argument to Trans and Final, hence the thesisis a straightforward consequence of the inductive hypothesis. 2It follows from the lemma that the axioms in T and F , together with the axioms forencoding of programs as first-order terms, completely determine the interpretation of thepredicates Trans and Final on the basis of the interpretation of the other predicates. That isT and F implicitly define the predicates Trans and Final. Formally, we have the followingtheorem:Theorem 2. There are no pair of models of C that differ only in the interpretation of thepredicates Trans and Final.Proof. By contradiction. Suppose that there are two models M1 and M2 of C that agreein the interpretation of all nonlogical symbols (constant, function, predicates) other thaneither Trans or Final. Let’s say that they disagree on Trans, i.e., there is a tuple ofdomain values . O(cid:14); Os; O(cid:14)0; Os0/ such that . O(cid:14); Os; O(cid:14)0; Os0/ 2 TransM1 and . O(cid:14); Os; O(cid:14)0; Os0/ =2 TransM2 .Considering the structure of the sort programs (see Appendix A), we have that for everyvalue of the domain of sort programs O(cid:14) there is a program term (cid:14).Ex/, containing onlyvariables Ex of sort object or action, such that for some assignment (cid:27) to Ex, (cid:14)M1;(cid:27) D (cid:14)M2;(cid:27) DO(cid:14). Now let us consider three variables s; (cid:14)0; s0 and an assignment (cid:27) 0 such that (cid:27) 0.Ex/ D (cid:27) .Ex/,(cid:27) 0.s/ D Os, (cid:27) 0.(cid:14)0/ D O(cid:14)0, and (cid:27) 0.s0/ D Os0. By Lemma 1, there exists a formula (cid:8) such thatneither Trans nor Final occurs in (cid:8) and:Mi; (cid:27) 0 jD Trans.(cid:14); s; (cid:14)0; s0/iff Mi; (cid:27) 0 jD (cid:8).Ex; s; (cid:14)0; s0/i D 1; 2:Since, M1; (cid:27) 0 jD (cid:8).Ex; s; (cid:14)0; s0/ iff M2; (cid:27) 0 jD (cid:8).Ex; s; (cid:14)0; s0/, we get a contradiction. 2G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–1691256. Some examples6.1. Two robots lifting a tableOur first example involves a simple case of concurrency: two robots that jointly lift atable. Test actions are used to synchronize the robots’ actions so that the table does not tipso much that objects on it fall off. Two instances of the same program are used to controlthe robots.(cid:15) Objects:Two agents: 8r: Robot.r/ (cid:17) r D Rob1 _ r D Rob2:Two table ends: 8e: TableEnd.e/ (cid:17) e D End1 _ e D End2:(cid:15) Primitive actions:grab.rob; end/;release.rob; end/;vmove.rob; z/ move robot arm up or down by z units:(cid:15) Primitive fluents:Holding.rob; end; s/;vpos.end; s/ D zheight of the table end:(cid:15) Initial state:8r; e: :Holding.r; e; S0/;8e: vpos.e; S0/ D 0:(cid:15) Precondition axioms:0Poss.grab.r; e/; s/ (cid:17) 8rPoss.release.r; e/; s/ (cid:17) Holding.r; e; s/;Poss.vmove.r; z/; s/ (cid:17) True:: :Holding.r0; e; s/ ^ 8e0: :Holding.r; e0; s/;(cid:15) Successor state axioms:Holding.r; e; do.a; s// (cid:17)a D grab.r; e/ _ Holding.r; e; s/ ^ a 6D release.r; e/;vpos.e; do.a; s// D p (cid:17)9r; z:.a D vmove.r; z/ ^ Holding.r; e; s/ ^ p D vpos.e; s/ C z/ _9r: a D release.r; e/ ^ p D 0 _p D vpos.e; s/ ^ :9r; z:.a D vmove.r; z/ ^ Holding.r; e; s// ^:9r: a D release.r; e/:126G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169The goal here is to get the table up, but to keep it sufficiently level so that nothing falls off.We can define these as follows:defD vpos.End1; s/ > H ^ vpos.End2; s/ > HTableUp.s/(both ends of the table are higher than some threshold H ),defD jvpos.End1; s/ (cid:0) vpos.End2; s/j 6 TolLevel.s/(both ends are at the same height to within a threshold Tol).So the goal isGoal.s/defD TableUp.s/ ^ 8s0:s0 6 s (cid:27) Level.s0/and the claim is that this goal can be achieved by having Rob1 and Rob2 each concurrentlyexecute the same procedure ctrl defined as:proc ctrl.rob/(cid:25)e:TTableEnd.e/?I grab.rob; e/UIwhile :TableUp.now/ doSafeToLift.rob; now/?Ivmove.rob; Amount/end,where Amount is some constant such that 0 < Amount < Tol, and SafeToLift is defined bySafeToLift.rob; s/defD 9e; e0: e 6D e0 ^ TableEnd.e/ ^ TableEnd.e0/ ^Holding.rob; e; s/ ^ vpos.e/ 6 vpos.e0/ C Tol (cid:0) Amount:Here, we use procedures simply for convenience and the reader can take them asabbreviations. A formal treatment for procedures will be provided in Section 7.So formally, the claim is: 8C [ D jD 8s:Do.ctrl.Rob1/kctrl.Rob2/; S0; s/ (cid:27) Goal.s/:Here is an informal sketch of a proof. Do holds if and only if there is a finite sequenceof transitions from the initial configuration .ctrl.Rob1/kctrl.Rob2/; S0/ to a configurationthat is Final. A program involving two concurrent processes can only get to a Finalconfiguration by reaching a configuration that is Final for both processes. The processesin our program involve while-loops, which only reach a final configuration when the loopcondition becomes is false. So the table must be high enough in the final situation.It remains to be shown that the table stayed level. Let vi stand for the actionvmove.robi ; Amount/: Suppose to the contrary that the table went too high on End1 heldby Rob1; and consider the first configuration where this became true. This situation in thisconfiguration is of the form do.v1; s/ wherevpos.End1; do.v1; s// > vpos.End2; do.v1; s// C Tol:8 Actually, proper termination of the program is also guaranteed. However, stating this condition formally, inthe case of concurrency, requires additional machinery, since 9s:Do.ctrl.Rob1/kctrl.Rob2/; S0; s/ is too weak.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169127However, at some earlier configuration, we had to have SafeToLift.Rob1; s0/ with nointervening actions by Rob1; otherwise the last v1 would not have been executed. Thismeans that we havevpos.End1; s0/ 6 vpos.End2; s0/ C Tol (cid:0) Amount:However, if all the actions between s0 and s are by Rob2; since Rob2 can only increase thevalue of vpos.End2/; it follows thatvpos.End1; s/ 6 vpos.End2; s/ C Tol (cid:0) Amount;that is, that SafeToLift was also true just before the final v1 action. This contradicts theassumption that v1 only adds Amount to the value of vpos.End1/.6.2. A reactive multi-elevator controllerOur next example involves a reactive controller for a bank of elevators; it illustrates theuse of interrupts and prioritized concurrency. The example will use the following terms(where e stands for an elevator):(cid:15) Ordinary primitive actions:goDown.e/goUp.e/buttonReset.n/toggleFan.e/ringAlarm(cid:15) Exogenous primitive actions:reqElevator.n/changeTemp.e/detectSmokeresetAlarm(cid:15) Primitive fluents:floor.e; s/ D ntemp.e; s/ D tFanOn.e; s/ButtonOn.n; s/Smoke.s/(cid:15) Defined fluents:move elevator down one floormove elevator up one floorturn off call button of floor nchange the state of elevator fanring the smoke alarm.call button on floor n is pushedthe elevator temperature changesthe smoke detector first senses smokethe smoke alarm is reset.the elevator is on floor n, 1 6 n 6 6the elevator temperature is tthe elevator fan is oncall button on floor n is onsmoke has been detected.TooHot.e; s/TooCold.e; s/defD temp.e; s/ > 1;defD temp.e; s/ < (cid:0)1:We begin with the following basic action theory for the above primitive actions and fluents:(cid:15) Initial state:floor.e; S0/ D 1; :FanOn.S0/;temp.e; S0/ D 0;ButtonOn.3; S0/; ButtonOn.6; S0/:128G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169(cid:15) Exogenous actions:8a:Exo.a/ (cid:17) a D detectSmoke _ a D resetAlarm _a D changeTemp.e/ _ 9n:a D reqElevator.n/:(cid:15) Precondition axioms:Poss.goDown.e/; s/ (cid:17) floor.e; s/ 6D 1;Poss.goUp.e/; s/ (cid:17) floor.e; s/ 6D 6;Poss.buttonReset.n/; s/ (cid:17) True;Poss.toggleFan.e/; s/ (cid:17) True;Poss.ringAlarm/ (cid:17) True;Poss.reqElevator.n/; s/ (cid:17) .1 6 n 6 6/ ^ :ButtonOn.n; s/;Poss.changeTemp; s/ (cid:17) True;Poss.detectSmoke; s/ (cid:17) :Smoke.s/;Poss.resetAlarm; s/ (cid:17) Smoke.s/:(cid:15) Successor state axioms:floor.e; do.a; s// D n (cid:17).a D goDown.e/ ^ n D floor.e; s/ (cid:0) 1/ _.a D goUp.e/ ^ n D floor.e; s/ C 1/ _.n D floor.e; s/ ^ a 6D goDown.e/ ^ a 6D goUp.e//;temp.e; do.a; s// D t (cid:17).a D changeTemp.e/ ^ FanOn.e; s/ ^ t D temp.e; s/ (cid:0) 1/ _.a D changeTemp.e/ ^ :FanOn.e; s/ ^ t D temp.e; s/ C 1/ _.t D temp.e; s/ ^ a 6D changeTemp.e//;FanOn.e; do.a; s// (cid:17).a D toggleFan.e/ ^ :FanOn.e; s// _.FanOn.e; s/ ^ a 6D toggleFan.e//;ButtonOn.n; do.a; s// (cid:17)a D reqElevator.n/ _.ButtonOn.n; s/ ^ a 6D buttonReset.n//;Smoke.do.a; s// (cid:17)a D detectSmoke _.Smoke.s/ ^ a 6D resetAlarm/:Note that many fluents are affected by both exogenous and programmed actions. Forinstance, the fluent ButtonOn is made true by the exogenous action reqElevator (i.e.,someone calls for an elevator) and made false by the programmed action buttonReset (i.e.,when an elevator serves a floor).G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169129Now we are ready to consider a basic elevator controller for an elevator e. It might bedefined by something like:while 9n:ButtonOn.n/ do(cid:25)n:fBestButton.n/?I serveFloor.e; n/g;while floor.e/ 6D 1 do goDown.e/.The fluent BestButton would be defined to select among all buttons that are currentlyon, the one that will be served next. For example, it might choose the button that hasbeen on the longest. For our purposes, we can take it to be any ButtonOn. The procedureserveFloor.e; n/ would consist of the actions the elevator would take to serve the requestfrom floor n. For our purposes, we can use:proc serveFloor.e; n/while floor.e/ < n do goUp.e/;while floor.e/ > n do goDown.e/;buttonReset.n/end.We have not bothered formalizing the opening and closing of doors, or other nastycomplications like passengers.As with Golog, we try to prove an existential and look at the bindings for the s. Theywill be of the form do.Ea; S0/ where Ea are the actions to perform. In particular, using thiscontroller program (cid:14), we would get execution traces likeC [ D jD Do.(cid:14) k (cid:14)EXO; S0; do.Tu; u; b3; u; u; u; b6; d; d; d; d; dU; S0//;C [ D jD Do.(cid:14) k (cid:14)EXO; S0; do.Tu; r4; u; b3; u; b4; u; u; r2; b6; d; d; d; d; b2; dU; S0//;: : :where u D goUp.e/, d D goDown.e/, bn D buttonReset.n/, rn D reqElevator.n/, and D isthe basic action theory specified above. In the first run there were no exogenous actions,while in the second, two elevator requests were made.This controller does have a big drawback, however: if no buttons are on, the first loopterminates, the elevator returns to the first floor and stops, even if buttons are pushed on itsway down. It would be better to structure it as two interrupts:h9n:ButtonOn.n/ !(cid:25)n:fBestButton.n/?I serveFloor.e; n/gi;h floor.e/ 6D 1 ! goDown.e/iwith the second at lower priority. So if no buttons are on, and you’re not on the first floor,go down a floor, and reconsider; if at any point buttons are pushed exogenously, pick oneand serve that floor, before checking again. Thus, the elevator only quits when it is on thefirst floor with no buttons on.130G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169With this scheme, it is easy to handle emergency or high-priority requests. We wouldaddh9n:EButtonOn.n/ !(cid:25)n:fEButtonOn.n/?I serveEFloor.e; n/gias an interrupt with a higher priority than the other two (assuming suitable additionalactions and fluents).To deal with the fan, we can add two new interrupts:hTooHot.e/ ^ :FanOn.e/ ! toggleFan.e/i;hTooCold.e/ ^ FanOn.e/ ! toggleFan.e/i:These should both be executed at the very highest priority. In that case, while serving afloor, whatever that amounts to, if the temperature ever becomes too hot, the fan will beturned on before continuing, and similarly if it ever becomes too cold. Note that if wedid not check for the state of the fan, this interrupt would loop repeatedly, never releasingcontrol to lower priority processes.Finally, imagine that we would like to ring a bell if smoke is detected, and disrupt normalservice until the smoke alarm is reset exogenously. To do so, we add the interrupt:hSmoke ! ringAlarmiwith a priority that is less than the emergency button, but higher than normal service. Oncethis interrupt is triggered, the elevator will stop and ring the bell repeatedly. It will handlethe fan and serve emergency requests, however.Putting all this together, we get the following controller:.hTooHot.e/ ^ :FanOn.e/ ! toggleFan.e/i khTooCold.e/ ^ FanOn.e/ ! toggleFan.e/i/ iih9n:EButtonOn.n/ !(cid:25)n:fEButtonOn.n/?I serveEFloor.e; n/gi iihSmoke ! ringAlarmi iih9n:ButtonOn.n/ !(cid:25)n:fBestButton.n/?I serveFloor.e; n/gi iih floor.e/ 6D 1 ! goDown.e/i:Using this controller (cid:14)r , we would get execution traces likeC [ D jD Do.(cid:14)r k (cid:14)EXO; S0; do.Tu; u; b3; u; u; u; b6; d; d; d; d; r5; u; u; u; b5; d; d; d;dU; S0//;C [ D jD Do.(cid:14)r k (cid:14)EXO; S0; do.Tu; u; b3; u; z; a; a; a; a; h; u; u; b6; d; d; d; d; dU;S0//;C [ D jD Do.(cid:14)r k (cid:14)EXO; S0; do.Tu; t; u; b3; u; t; f; u; t; t; u; t; b6; d; t; f; d; t; d; d;dU; S0//;: : :G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169131where z D detectSmoke, a D ringAlarm, h D resetAlarm, t D changeTemp, and f DtoggleFan. In the first run, we see that this controller does handle requests that come inwhile the elevator is on its way to retire on the bottom floor. The second run illustrates howthe controller reacts to smoke being detected by ringing the alarm. The third run showshow the controller reacts immediately to temperature changes while it is serving floors.Note that this elevator controller uses 5 different levels of priority. It could have beenprogrammed in Golog without interrupts, but the code would have been a lot messier.Now let us suppose that we would like to write a controller that handles two independentelevators. In ConGolog, this can be done very elegantly using .(cid:14)1 k (cid:14)2/, where (cid:14)1 is theabove program with e replaced by Elevator1 and (cid:14)2 is the same program with e replacedby Elevator2. This allows the two processes to work completely independently (in termsof priorities). 9 For n elevators, we would use .(cid:14)1 k (cid:1) (cid:1) (cid:1) k (cid:14)n/.6.3. A client–server systemIn some applications, it is useful to have an unbounded number of instances of a processrunning concurrently. For example in an FTP server, we may want an instance of a managerprocess for each active FTP session. This can be programmed using the (cid:14)jj concurrentiteration construct.Let us give a high-level sketch of how this might be done. Suppose that there isan exogenous action newClient.cid/ that occurs when a new client with the ID cidfirst requests service. Also assume that a procedure serve.cid/ has been defined, whichimplements the behavior required for the server for a given client. To set up the system, werun the program:T(cid:25) cid: acquire.cid/I serve.cid/UjjI:9cid: .ClientWaiting.cid//?Here, we assume that when the exogenous action newClient.cid/ occurs, it makes thefluent ClientWaiting.cid/ true. Then, the only way the computation can be completed isby generating a new process that first acquires the client by doing acquire.cid/, and thenserves it. We formalize this as follows:Poss.acquire.cid/; s/ (cid:17) ClientWaiting.cid/;ClientWaiting.cid; do.a; s// (cid:17)a D newClient.cid/ _ ClientWaiting.cid; s/ ^ a 6D acquire.cid/U:Then, only a single process can acquire a given client, since acquire is only possiblewhen ClientWaiting.cid/ is true and performing it makes this fluent false. The wholeprogram can only reach a final configuration if it forks exactly the right number of serverprocesses: at least one for each client because a server can only acquire one client, and nomore than one for each client because servers can be activated only if they can acquire aclient.9 Of course, when an elevator is requested on some floor, both elevators may decide to serve it. It is easy toprogram a better strategy that coordinates the elevators: when an elevator decides to serve a floor, it immediatelymakes a fluent true for that floor, and the other elevator will not serve a floor for which that fluent is already true.132G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–1696.4. Actions with extended durationOne possible criticism of our approach to concurrency is that it does not work whenwe consider actions that have extended duration. Consider singing while filling the bathtubwith water, for example. If one of the actions involved is “filling the bathtub”, and the otheractions are “singing do”, “singing re”, and “singing mi”, say, then there are exactly fourpossible interleavings,Tfilling I do I re I miU;Tdo I filling I re I miU;Tdo I re I filling I miU;Tdo I re I mi I fillingU;but none of them capture the idea of singing and filling the tub at the same time. Moreover,the prospect of replacing the filling action by a large number of component actions (thatcould be interleaved with the singing ones) is even less appealing.To deal with this type of case, we recommend the following approach (see [33] for adetailed presentation): instead of thinking of filling the bathtub as an action or group ofactions, think of it as a state that an agent could be in, extending possibly over manysituations. The idea is that the agent can be in many such states simultaneously, includinglistening to the radio, walking, and chewing gum. For each such state, we need twoprimitive actions and a fluent; for the bathtub, they are startFilling, which puts the agentinto the state, and endFilling, which terminates it, as well as the fluent FillingTub, whichholds in those situations where the agent is filling the tub. Formally, we would express thiswith a successor state axiom as follows:FillingTub.do.a; s// (cid:17)a D startFilling _ FillingTub.s/ ^ a 6D endFilling:Since the startFilling and endFilling actions can be taken to be instantaneous, theinterleaving account is once again plausible. If we define a complex actionFillTheTubdefD TstartFilling I endFillingU;and run it concurrently with the singing, then we get these possible interleavings:TstartFilling I endFilling I do I re I miU;TstartFilling I do I endFilling I re I miU;TstartFilling I do I re I endFilling I miU;TstartFilling I do I re I mi I endFillingU;Tdo I startFilling I endFilling I re I miU;Tdo I startFilling I re I endFilling I miU;Tdo I startFilling I re I mi I endFillingU;G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169133Tdo I re I startFilling I endFilling I miU;Tdo I re I startFilling I mi I endFillingU;Tdo I re I mi I startFilling I endFillingU:A better model would be something likeFillTheTubdefD TstartFilling I .waterLevel > H /? I endFillingU;which would rule out interleavings where the filling stops too soon. The most natural wayof modeling the water level is as a continuous function of time: l D L0 C R (cid:2) t; where L0 isthe initial level, R is the rate of filling (taken to be constant), and t is the elapsed time. Onesimple way to accommodate this idea within the situation calculus is to assume that everyaction has a duration dur.a/ (which we could also make dependent on the situation theaction is performed in). Actions such as startFilling can have duration 0, but there must besome action, if only a timePasses, with a non-0 duration. We then describe the waterLevelfunctional fluent by:waterLevel.do.a; s// D waterLevel.s/ C waterRate.s/ (cid:2) dur.a/;waterRate.do.a; s// D if FillingTub.s/ then R else 0:So as long as a situation is in a filling-the-tub state, the water level rises according to theabove equation. In terms of concurrency, the result is that the only allowable interleavingswould be those where enough actions of sufficient duration occur between the startFillingand stopFilling.Of course, this model of the continuous process of water entering the bathtub does notallow us to predict the eventual outcome, for example, the water overflowing if a tap is notturned off, etc. A more complex program, typically involving interrupts, would be required,so that suitable “trajectory altering” actions are triggered under the appropriate conditions.7. Extending the transition semantics to proceduresWe now extend the transition semantics introduced above to deal with procedures.Because a recursive procedure may do an arbitrary number of procedure calls before itperforms a primitive action or test, and such procedure calls are not viewed as transitions,we must use a second-order definition of Trans and Final. In doing so, great care has tobe put in understanding the interaction between recursive procedures and the very generalform of prioritized concurrency allowed in ConGolog.Let proc P1.Ev1/(cid:14)1 endI : : : I proc Pn.Evn/(cid:14)n end be a collection of procedure definitions.We call such a collection an environment and denote it by Env. In a procedure definitionproc Pi .Evi /(cid:14)i end, Pi is the name of the ith procedure in Env; Evi are its formal parameters;and (cid:14)i is the procedure body, which is a ConGolog program, possibly including bothprocedure calls and new procedure definitions. We use call-by-value as the parameterpassing mechanism, and lexical (or static) scope as the scoping rule.134G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Formally we introduce three program constructs:(cid:15) P .Et/ where P is a procedure name and Et actual parameters associated to the procedureP ; as usual we replace the situation argument in the terms constituting Et by now.P .Et / denotes a procedure call, which invokes procedure P on the actual parameters Etevaluated in the current situation.(cid:15) fEnvI (cid:14)g, where Env is an environment and (cid:14) is a program extended with procedurescalls. fEnvI (cid:14)g binds procedures calls in (cid:14) to the definitions given in Env. The usualnotion of free and bound apply, so for, e.g., in fproc P1./ a endI P2./I P1./g, P1 isbound but P2 is free.(cid:15) TEnv V P .Et /U, where Env is an environment, P a procedure name and Et actualparameters associated to the procedure P . TEnv V P .Et /U denotes a procedure call thathas been contextualized: the environment in which the definition of P is to be lookedfor is Env.We define the semantics of ConGolog programs with procedures by defining both Transand Final by a second-order formula (instead of a set of axioms). 10 Trans is defined asfollows:Trans.(cid:14); s; (cid:14)0; s0/ (cid:17) 8T :T: : : (cid:27) T .(cid:14); s; (cid:14)0; s0/U;T —i.e., the set of axioms T modulo textualwhere : : : stands for the conjunction of T Transsubstitution of Trans with T —and (the universal closure of) the following two assertions:(cid:0)(cid:14)Pi .Et/TEnvVPi .Et/U; s; (cid:14)0; s0(cid:0)fEnvI (cid:14)PT .fEnvI (cid:14)g; s; (cid:14)0; s0/ (cid:17) TT .TEnv V P .Et /U; s; (cid:14)0; s0/ (cid:17) T(cid:1);g; s; (cid:14)0; s0(cid:1);EvPEt TsUwhere (cid:14)Pi .Et/TEnvVPi .Et/U denotes the program (cid:14) with all procedures bound by Env and free in (cid:14)EvPreplaced by their contextualized version (this gives us the lexical scope), and where (cid:14)PEtTsUdenotes the body of the procedure P in Env with formal parameters Ev substituted by theactual parameters Et evaluated in the current situation.Similarly, Final is defined as follows:Final.(cid:14); s/ (cid:17) 8F:T: : : (cid:27) F .(cid:14); s/U;where : : : stands for the conjunction of F Finalsubstitution of Final with F —and (the universal closure of) the following assertions:(cid:1)F —i.e., the set of axioms F modulo textualF .fEnvI (cid:14)g; s/ (cid:17) FF .TEnv V P .Et/U; s/ (cid:17) F(cid:0)(cid:14)Pi .Et/TEnvVPi .Et/U; s(cid:0)fEnvI (cid:14)P;EvPEt TsUg; s(cid:1):Note that no assertions for (uncontextualized) procedure calls are present in the definitionsof Trans and Final. Indeed a procedure call which cannot be bound to a proceduredefinition neither can do transitions nor can be considered successfully completed.10 For compatibility with the formalization in Section 4, we treat Trans and Final as predicates, although it isclear that they could be understood as abbreviations for the second-order formulas.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169135Observe also the two uses of substitution to deal with procedure calls. When a programwith an associated environment is executed, for all procedure calls bound by Env,we simultaneously substitute the corresponding procedure calls, contextualized by theenvironment of the procedure in order to deal with further procedure calls according tothe static scope rules. Then when a (contextualized) procedure is actually executed, theactual parameters are first evaluated in the current situation, and then are substituted forthe formal parameters in the procedure bodies, 11 thus yielding call-by-value parameterpassing.The following example program (cid:14)StSc illustrates ConGolog’s static scoping:f proc P1./aendIproc P2./P1./endIproc P3./f proc P1./bendIP2./I P1./gendIP3./g.One can show that for this program, the sequence of atomic actions performed will be afollowed by b (assuming that both a and b are always possible):8s:TPoss.a; s/ ^ Poss.b; s/U (cid:27)8s; s:TDo.(cid:14)StSc; s; s/ (cid:17) s000 D do.b; do.a; s//U:To see this consider the following. LetEnv1defD proc P1./ a end;proc P2./ P1./ end;proc P3./ fEnv2I P2./I P1./g end,Env2defD proc P1./ b end.Then it is easy to see that:Trans.(cid:14)StSc; s; (cid:14)0; s0/(cid:17) Trans.fEnv1I P3./g; s; (cid:14)0; s0/11 To be more precise, every formal parameter v is substituted by a term of the form nameOf.tTsU/, where againnameOf is used to convert situation calculus objects/actions into program terms of the corresponding sort (seeAppendix A).136G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169(cid:17) Trans.TEnv1 V P3./U; s; (cid:14)0; s0/(cid:17) Trans.fEnv1I fEnv2I P2./I P1./gg; s; (cid:14)0; s0/0(cid:17) Trans.fEnv2I TEnv1 V P2./UI P1./g; s; (cid:14)/; s(cid:17) Trans.TEnv1 V P2./UI TEnv2 V P1./U; s; (cid:14)0; s0/(cid:17) Trans.fEnv1I P1./gI TEnv2 V P1./U; s; (cid:14)0; s0/(cid:17) Trans.TEnv1 V P1./UI TEnv2 V P1./U; s; (cid:14)0; s0/(cid:17) Trans.aI TEnv2 V P1./U; s; (cid:14)0; s0/0 D do.a; s/ ^ (cid:14)(cid:17) Poss.a; s/ ^ s00 D .nilI TEnv2 V P1./U/:Similarly, one can show that: Trans.TEnv2 V P1./U; do.a; s/; nil; do.b; do.a; s/// andFinal.nil; do.b; do.a; s///, which yields the thesis.Our next example illustrates ConGolog’s call-by-value parameter passing:f proc P .n/if .n D 1/ then nilelse goDownI P .n (cid:0) 1/endIP . floor/g.Intuitively, this program is intended to bring an elevator down to the bottom floor of abuilding. If we run the program starting in situation S0, the procedure call P . floor/ invokesP with the value of the functional fluent floor in S0, i.e., P is called with floorTS0U, the floorthe elevator is on in S0, as actual parameter. If ConGolog used call-by-name parameterpassing, P would be invoked with the term “floor” as actual parameter, and the elevatorwould only go halfway to the bottom floor. Indeed at each iteration of the procedure thecall P .n (cid:0) 1/ would be evaluated by textually replacing n by floor, which at that momenthas already decreased by 1.As mentioned earlier, the need for a second-order definition of Trans.(cid:14); s; (cid:14)0; s0/ andFinal.(cid:14); s/ when procedures are introduced comes from recursive procedures. The second-order definition allows us to assign a formal semantics to every such procedure, includingviciously circular ones. The definition of Trans disallows the execution of such ill-formed procedures. At the same time the definition of Final considers them not to havecompleted (nonfinal). For example, the program fproc P ./ P ./ endI P ./g does not haveany transitions, but it is not final for any situation s. 127.1. Formal properties of Trans and Final with proceduresWe observe that the second-order definitions of Trans and Final can easily be put in thefollowing form:Trans.(cid:14); s; (cid:14); s00/ (cid:17)(cid:27) T .(cid:14); s; (cid:14)0; s0/;8T :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.T ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) T .(cid:14)1; s1; (cid:14)2; s2/U12 Note that both Golog and ConGolog do not allow for Boolean procedures to be used in tests. Introducing suchkind of procedures requires particular care to avoid counterintuitive implications.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169137Final.(cid:14); s; (cid:14)0; s0/ (cid:17)8F:T8(cid:14)1; s1: (cid:8)Final.F; (cid:14)1; s1/ (cid:17) F .(cid:14)1; s1/U(cid:27) F .(cid:14); s/;where (cid:8)Trans and (cid:8)Final are obtained by rewriting each of the assertions in the definitionof Trans and Final so that only variables appear in the left-hand part of the equations, i.e.:T .(cid:14); s; (cid:14)0; s0/ (cid:17) (cid:30)t .T ; (cid:14); s; (cid:14)0; s0/;F .(cid:14); s/ (cid:17) (cid:30)f .F; (cid:14); s/;and then getting the disjunction of all right-hand sides, which are mutually exclusive sinceeach of them deals with programs of a specific form.From such definitions, natural “induction principles” emerge (cf. the discussion onextracting induction principles from inductive definitions in [34]). These are principlessaying that to prove that a property P holds for instances of Trans and Final, it sufficesto prove that the property P is closed under the assertions in the definition of Trans andFinal, i.e.:(cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/;(cid:8)Final.P ; (cid:14)1; s1/ (cid:17) P .(cid:14)1; s1/:Formally we can state the following theorem:Theorem 3. The following sentences are consequences of the second-order definitions ofTrans and Final respectively:8P :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/U (cid:27)8(cid:14); s; (cid:14)0; s0: Trans.(cid:14); s; (cid:14)0; s0/ (cid:27) P .(cid:14); s; (cid:14)0; s0/;8P :T8(cid:14)1; s1: (cid:8)Final.P ; (cid:14)1; s1/ (cid:17) P .(cid:14)1; s1/U (cid:27)00; s8(cid:14); s: Final.(cid:14); s; (cid:14)/ (cid:27) P .(cid:14); s/:Proof. We prove only the first sentence. The proof of the second sentence is analogous.By definition we have:00008(cid:14); s; (cid:14)0; s: Trans.(cid:14); s; (cid:14); s0/ (cid:17)8P :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/U(cid:27) P .(cid:14); s; (cid:14)0; s0/:By considering the only-if part of the above equivalence, we get:8(cid:14); s; (cid:14)0; s: Trans.(cid:14); s; (cid:14); s0/ ^8P :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/U(cid:27) P .(cid:14); s; (cid:14)0; s0/:So moving the quantifiers around we get:8P :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/U ^8(cid:14); s; (cid:14)0; s0: Trans.(cid:14); s; (cid:14)0; s0/(cid:27) P .(cid:14); s; (cid:14)0; s0/;and hence the thesis. 2138G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169These induction principles allow us to prove that Trans and Final for programs withprocedures can be considered an extension of those for programs without procedures.Theorem 4. With respect to ConGolog programs without procedures, Trans and Finalintroduced above are equivalent to the versions introduced in Section 4.Proof. Let us denote Trans defined by the second-order sentence as TransSOL and Transimplicitly defined through axioms in Section 4 as TransFOL. Since procedures are notconsidered we can drop, without loss of generality, the assertions for fEnvI (cid:14)g and TEnv VP .Et/U in the definition of TransSOL. Then:(cid:15) TransSOL.(cid:14); s; (cid:14)0; s0/ (cid:27) TransFOL.(cid:14); s; (cid:14)0; s0/,is proven simply by noting thatTransFOL satisfies (is closed under) the assertions in the definition of TransSOL, andthen using Theorem 3.(cid:15) TransFOL.(cid:14); s; (cid:14)0; s0/ (cid:27) TransSOL.(cid:14); s; (cid:14)0; s0/, is proven by induction on the structureof (cid:14) considering as base cases nil, a, and (cid:30)?, and then applying the inductionargument.Similarly for Final. 2It is interesting to examine whether Trans and Final introduced above are themselvesclosed under the assertions in their definitions. For Final a positive answer can beestablished:Theorem 5. The following sentence is a consequence of the second-order definition ofFinal:(cid:8)Final.Final.(cid:14); s/; (cid:14); s/ (cid:17) Final.(cid:14); s/:Proof. Observe that (cid:8)Final is monotonic, 13 i.e.:8Z1; Z2:T8(cid:14); s:Z1.(cid:14); s/ (cid:27) Z2.(cid:14); s/U (cid:27) T8(cid:14); s:(cid:8)Final.Z1; (cid:14); s/ (cid:27) (cid:8)Final.Z2; (cid:14); s/U:Hence the thesis is a direct consequence of the Tarski–Knaster fixpoint theorem [40]. 2For Trans an analogous result does not hold in general. Indeed consider the followingprogram (cid:14)q :f proc Q./Q./ ii aendIQ./g.Observe that the definition of Trans implies that Trans.(cid:14)q ; s; (cid:14)0; s0/ (cid:17) False. Hence if Transwas closed under (cid:8)Trans, then we would have Trans.(cid:14)q ii a; s; (cid:14)0; s0/ (cid:17) Trans.a; s; (cid:14)0; s0/,which would imply that Trans.(cid:14)q ; s; (cid:14)0; s0/ (cid:17) Trans.a; s; (cid:14)0; s0/. Contradiction.13 In fact syntactically monotonic.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169139Obviously there are several classes of ConGolog programs that are closed under (cid:8)Trans.For instance, if we disallow prioritized concurrency in procedures we get one such class.Another such class is that obtained by allowing prioritized concurrency to appear only innonrecursive procedures. Yet another quite general class is immediately obtainable fromwhat is discussed next.8. First-order Trans and Final for proceduresIn this section we investigate conditions that allow us to replace the second-orderdefinitions of Trans and Final for programs with procedures by the first-order definitions,as in the case where procedures are not allowed.8.1. Guarded configurationsWe define a quite general condition on configurations (pairs of programs and situations)that guarantees the possibility of using first-order axioms for Trans and Final forprocedures as well. To this end we introduce a notion of “configuration rank”. Intuitively, aconfiguration is of rank n if and only if makes at most n (recursive) procedure calls beforetrying to make an actual program step (either an atomic action or a test).We define the rank of a configuration inductively. A configuration is of rank n denotedby Rank.n; (cid:14); s/ if and only if:Rank.n; nil; s/ (cid:17) True;Rank.n; a; s/ (cid:17) True;Rank.n; (cid:30)?; s/ (cid:17) True;Rank.n; (cid:14)1I (cid:14)2; s/ (cid:17) Rank.n; (cid:14)1; s/ ^ .Final.(cid:14)1; s/ (cid:27) Rank.n; (cid:14)2; s//;Rank.n; (cid:14)1 j (cid:14)2; s/ (cid:17) Rank.n; (cid:14)1; s/ ^ Rank.n; (cid:14)2; s/;Rank.n; (cid:25)v:(cid:14); s/ (cid:17) 8x:Rank.n; (cid:14)vRank.n; (cid:14)(cid:3); s/ (cid:17) Rank.n; (cid:14); s/;Rank.n; if (cid:30) then (cid:14)1 else (cid:14)2; s/ (cid:17) (cid:30)TsU ^ Rank.n; (cid:14)1; s/ _:(cid:30)TsU ^ Rank.n; (cid:14)2; s/;x ; s/;Rank.n; while (cid:30) do (cid:14); s/ (cid:17) (cid:30)TsU (cid:27) Rank.n; (cid:14); s/;Rank.n; (cid:14)1 k (cid:14)2; s/ (cid:17) Rank.n; (cid:14)1; s/ ^ Rank.n; (cid:14)2; s/;Rank.n; (cid:14)1 ii (cid:14)2; s/ (cid:17) Rank.n; (cid:14)1; s/ ^Rank.n; (cid:14)jj; s/ (cid:17) Rank.n; (cid:14); s/;(cid:0)n; (cid:14)Pi .Et/Rank.n; fEnvI (cid:14)g; s/ (cid:17) RankTEnvVPi .Et/U; s(cid:0)Rank.n; TEnv V P .Et/U; s/ (cid:17) Rankn (cid:0) 1; fEnvI (cid:14)P(cid:1);(cid:1):EvPEt TsUg; s..:9(cid:14)01; s0:Trans.(cid:14)1; s; (cid:14)01; s0// (cid:27) Rank.n; (cid:14)2; s//;140G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169A configuration .(cid:14); s/ is guarded if and only if it is of rank n for some n:Guarded.(cid:14); s/defD 9n: Rank.n; (cid:14); s/:8.2. First-order Trans and Final for proceduresFor guarded configurations, we do not need to use the second-order definitions of Transand Final when dealing with procedures. Instead we can use the first-order axioms inSection 4 together with the following: 14(cid:0)(cid:14)Pi .Et/Trans.fEnvI (cid:14)g; s; (cid:14)0; s0/ (cid:17) TransTEnvVPi .Et/U; s; (cid:14)0; s0(cid:0)Trans.TEnv V P .Et/U; s; (cid:14)0; s0/ (cid:17) TransfEnvI (cid:14)P(cid:1);g; s; (cid:14)0; s0(cid:1);EvPEtTsU(cid:0)(cid:14)Pi .Et/Final.fEnvI (cid:14)g; s/ (cid:17) FinalTEnvVPi .Et/U; s(cid:0)Final.TEnv V P .Et/U; s/ (cid:17) FinalfEnvI (cid:14)P(cid:1);EvPEtTsUg; s(cid:1):Let us call TransFOL and FinalFOL the predicates determined by the first-order axiomsand TransSOL and FinalSOL the original predicates determined by the second-orderdefinition for procedures. We can prove the following result:Theorem 6.Guarded.(cid:14); s/ (cid:27)8(cid:14)0; s0:TransSOL.(cid:14); s; (cid:14)0; s0/ (cid:17) TransFOL.(cid:14); s; (cid:14)0; s0/;Guarded.(cid:14); s/ (cid:27)FinalSOL.(cid:14); s/ (cid:17) FinalFOL.(cid:14); s/:Proof (Outline). By induction on the rank of the configuration .(cid:14); s/. For rank 0 the thesisis trivial. For rank n C 1, we assume that the thesis holds for all configurations of rank n,and show the thesis by induction on the structure of the program considering nil, a, (cid:30)? andTEnv V P .Et /U as base cases. 2A configuration .(cid:14); s/ has a guarded evolution, if and only if:GuardedEvol.(cid:14); s/(cid:3)8(cid:14)0; s0:TransdefDSOL.(cid:14); s; (cid:14)0; s0/ (cid:27) Guarded.(cid:14)0; s0/:For configurations with guarded evolution we have the following easy consequences:008(cid:14)GuardedEvol.(cid:14); s/ (cid:27)(cid:3)SOL.(cid:14); s; (cid:14):TransGuardedEvol.(cid:14); s/ (cid:27); s8s0:DoSOL.(cid:14); s; s0/ (cid:17) DoFOL.(cid:14); s; s0/:0; s0(cid:3)/ (cid:17) TransFOL.(cid:14); s; (cid:14)00/;; s14 The form of these axioms is exactly that of the conditions on the predicate variables T and F in the second-order definitions.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–1691418.3. Sufficient condition for guarded evolutionsTheorem 7. If all procedures P with environment Env in a program (cid:14) are such that8Et; s:Guarded.TEnv V P .Et/U; s/;then we have:8s:GuardedEvol.(cid:14); s/:Proof (Outline). By induction on the number of transitions. For 0 transitions, we get thethesis by induction on the structure of the program (considering nil; a; (cid:30)? and TEnv V P .Et /Uas base cases). For k C 1 transitions, we assume the thesis holds for k transitions, andwe prove by induction on the structure of the program (again considering nil; a; (cid:30)? andTEnv V P .Et /U as base cases) that making a further transition from the program resultingfrom the k transitions still preserves the thesis. 2It is easy to verify that nonrecursive procedures, as well as procedures whose body startswith an atomic action or a wait action, trivially satisfy the hypothesis of the theorem.Observe also that all procedures in [20] satisfy such hypothesis, except for the procedured at p. 9 whose definition is reported below (n is a natural number):proc d.n/ .n D 0?/ j d.n (cid:0) 1/I goDown end:However, the variantsproc d.n/ .n D 0?/ j goDownI d.n (cid:0) 1/ endproc d.n/ .n D 0?/ j .n > 0/?I d.n (cid:0) 1/I goDown endproc d.n/ if .n D 0/ then nil else .d.n (cid:0) 1/I goDown/ enddo satisfy the hypothesis.9. ImplementationDespite the fact that in defining the semantics of ConGolog we resorted to first- andsecond-order logic, it is possible to come up with a simple implementation of the ConGologlanguage in Prolog.In this section, we present a ConGolog interpreter in Prolog which is lifted directly fromthe definition of Final, Trans, and Do introduced above. 15 This interpreter requires thatthe program’s precondition axioms, successor state axioms, and axioms about the initialsituation be expressible as Prolog clauses. In particular, the usual closed world assumption(CWA) is made on the initial situation. Note that this is a limitation of this particularimplementation, not the theory.15 Exogenous actions can be generated by simulating them probabilistically, by asking the user at runtime whenthey should occur, or by monitoring the environment in which the program is running.142G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Prolog terms representing ConGolog programs are as follows:(cid:15) nil, empty program.(cid:15) act.a/, atomic action, where a is an action term with the situation argumentsreplaced by the constant now.(cid:15) test.c/, wait/test, where c is a condition described below.(cid:15) seq.p1; p2/, sequence.(cid:15) choice.p1; p2/, nondeterministic branch.(cid:15) pick.v; p/, nondeterministic choice of argument, where v is a Prolog constant(atom), standing for a ConGolog variable, and p a program-term that uses v.(cid:15) iter.p/, nondeterministic iteration.(cid:15) if.c; p1; p2/, if-then-else, with p1 the then-branch and p2 the else-branch.(cid:15) while.c; p/, while-do.(cid:15) conc.p1; p2/, concurrency.(cid:15) prconc.p1; p2/, prioritized concurrency.(cid:15) iterconc.p/, iterated concurrency.(cid:15) pcall.pArgs/, procedure call, with pArgs the procedure name and arguments.A condition c in the above is either a Prolog-term representing an atomic formula/fluentwith the situation arguments replaced by now or an expression of the form and.c1; c2/,or.c1; c2/, neg.c/, all.v; c/, or some.v; c/, with the obvious intended meaning. Inall.v; c/ and some.v; c/, v is an Prolog constant, standing for a logical variable, andc a condition using v.The Prolog predicate trans=4, final=2, trans(cid:3)=4 and do=3 implement respec-tively the predicate Trans, Final, Trans(cid:3) and Do.The Prolog predicate holds=2 is used to evaluate conditions in tests, while-loops andif-then-else’s in ConGolog programs. As well, the Prolog predicate sub=4 implements thesubstitution so that sub.x; y; t; t 0/ means that t 0 D t xy . The definition of these two Prologpredicates is taken from [20,34].The following is the Prolog code./************************************************************//**//************************************************************/Trans-based ConGolog Interpreter/* trans(Prog,Sit,Prog_r,Sit_r) */trans(act(A),S,nil,do(AS,S)) :- sub(now,S,A,AS), poss(AS,S).trans(test(C),S,nil,S) :- holds(C,S).trans(seq(P1,P2),S,P2r,Sr) :- final(P1,S),trans(P2,S,P2r,Sr).trans(seq(P1,P2),S,seq(P1r,P2),Sr) :- trans(P1,S,P1r,Sr).trans(choice(P1,P2),S,Pr,Sr) :-trans(P1,S,Pr,Sr) ; trans(P2,S,Pr,Sr).trans(pick(V,P),S,Pr,Sr) :- sub(V,_,P,PP), trans(PP,S,Pr,Sr).G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169143trans(iter(P),S,seq(PP,iter(P)),Sr) :- trans(P,S,PP,Sr).trans(if(C,P1,P2),S,Pr,Sr) :-holds(C,S), trans(P1,S,Pr,Sr) ;holds(neg(C),S), trans(P2,S,Pr,Sr).trans(while(C,P),S,seq(PP,while(C,P)),Sr) :-holds(C,S), trans(P,S,PP,Sr).trans(conc(P1,P2),S,conc(P1r,P2),Sr) :- trans(P1,S,P1r,Sr).trans(conc(P1,P2),S,conc(P1,P2r),Sr) :- trans(P2,S,P2r,Sr).trans(prconc(P1,P2),S,prconc(P1r,P2),Sr) :-trans(P1,S,P1r,Sr).trans(prconc(P1,P2),S,prconc(P1,P2r),Sr) :-not trans(P1,S,_,_), trans(P2,S,P2r,Sr).trans(iterconc(P),S,conc(PP,iterconc(P)),Sr) :-trans(P,S,PP,Sr).trans(pcall(P_Args),S,Pr,Sr) :-sub(now,S,P_Args,P_ArgsS),proc(P_ArgsS,P), trans(P,S,Pr,Sr)./* final(Prog,Sit) */final(nil,S).final(seq(P1,P2),S) :- final(P1,S), final(P2,S).final(choice(P1,P2),S) :- final(P1,S) ; final(P2,S).final(pick(V,P),S) :- sub(V,_,P,PP), final(PP,S).final(iter(P),S).final(if(C,P1,P2),S) :-holds(C,S),final(P1,S) ; holds(neg(C),S),final(P2,S).final(while(C,P),S) :- holds(neg(C),S) ; final(P,S).final(conc(P1,P2),S) :- final(P1,S), final(P2,S).final(prconc(P1,P2),S) :- final(P1,S), final(P2,S).final(iterconc(P),S).final(pcall(P_Args)) :-sub(now,S,P_Args,P_ArgsS), proc(P_ArgsS,P),final(P,S).144G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169/* trans*(Prog,Sit,Prog_r,Sit_r) */trans*(P,S,P,S).trans*(P,S,Pr,Sr) :- trans(P,S,PP,SS), trans*(PP,SS,Pr,Sr)./* do(Prog,Sit,Sit_r) */do(P,S,Sr) :- trans*(P,S,Pr,Sr), final(Pr,Sr)./* holds(Cond,Sit): as defined in [34] */holds(and(F1,F2),S) :- holds(F1,S), holds(F2,S).holds(or(F1,F2),S) :- holds(F1,S) ; holds(F2,S).holds(all(V,F),S) :- holds(neg(some(V,neg(F))),S).holds(some(V,F),S) :- sub(V,_,F,Fr), holds(Fr,S).holds(neg(neg(F)),S) :- holds(F,S).holds(neg(and(F1,F2)),S) :- holds(or(neg(F1),neg(F2)),S).holds(neg(or(F1,F2)),S) :- holds(and(neg(F1),neg(F2)),S).holds(neg(all(V,F)),S) :- holds(some(V,neg(F)),S).holds(neg(some(V,F)),S) :- not holds(some(V,F),S)./* Negation by failure */holds(P_Xs,S) :-P_Xs\=and(_,_),P_Xs\=or(_,_),P_Xs\=neg(_),P_Xs\=all(_,_),P_Xs\=some(_,_),sub(now,S,P_Xs,P_XsS), P_XsS.holds(neg(P_Xs),S) :-P_Xs\=and(_,_),P_Xs\=or(_,_),P_Xs\=neg(_),P_Xs\=all(_,_),P_Xs\=some(_,_),sub(now,S,P_Xs,P_XsS), not P_XsS./* Negation by failure *//* sub(Const,Var,Term1,Term2): as defined in [34] */sub(X,Y,T,Tr) :- var(T), Tr=T.sub(X,Y,T,Tr) :- not var(T), T=X, Tr=Y.sub(X,Y,T,Tr) :-T\=X, T=..[F|Ts], sub_list(X,Y,Ts,Trs), Tr=..[F|Trs].sub_list(X,Y,[],[]).sub_list(X,Y,[T|Ts],[Tr|Trs]) :-sub(X,Y,T,Tr), sub_list(X,Y,Ts,Trs).In this implementation a ConGolog application is expected to have the following parts:(1) A collection of clauses which together define which fluents are true in the initialsituation s0. The clauses need not to be atomic, and can involve arbitrary amountsof computation for determining entailments in the initial database.(2) A collection of clauses which together define the predicate Poss.a; s/ for everyaction a and situation s. Typically, this requires one clause per action, using avariable to range over all situations.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169145(3) A collection of clauses which together define the successor state axioms for eachfluent. Typically, this requires one clause per fluent, with variables for actions andsituations.(4) A collection of facts defining ConGolog procedures. In particular for each procedurep occurring in the program we have a fact of the form:proc.p.X1; : : : ; Xn/; body/:In such facts:(i) formal parameters are represented as Prolog variables so as to use Prolog built-in unification mechanism instead of a substitution procedure;(ii) in the body body the only variables that can occur are those representing theformal parameters X1; : : : ; Xn.For simplicity, we do not consider nested procedures in the above implementation.Expressing action theories as Prolog clauses places a number of restrictions on theaction theories that are representable. These restrictions force the closed world assumption(Prolog CWA) on the initial situation and the unique name assumption (UNA) on bothactions and objects. For an in-depth study on action theories expressible as Prolog clauses,we refer to [34].9.1. ExampleBelow, we give an implementation in Prolog of the two robots lifting a table sce-nario discussed in Section 6.1. The code is written as close to the specification as possi-ble. The inability of Prolog to define directly the functional fluent vpos.e; s/ is resolvedby introducing a predicate val=2 such that val.vpos.e; s/; v/ stands for vpos.e; s/D v./************************************************************//**//************************************************************/Two Robots Lifting a Table Example/* Precondition axioms */poss(grab(Rob,E),S) :-not holding(_,E,S), not holding(Rob,_,S).poss(release(Rob,E),S) :- holding(Rob,E,S).poss(vmove(Rob,Amount),S) :- true./* Succ state axioms */val(vpos(E,do(A,S)),V) :-(A=vmove(Rob,Amount), holding(Rob,E,S), val(vpos(E,S),V1),V is V1+Amount) ;146G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169(A=release(Rob,E), V=0) ;(val(vpos(E,S),V),not(A=vmove(Rob,Amount), holding(Rob,E,S)),A\=release(Rob,E)).holding(Rob,E,do(A,S)) :-A=grab(Rob,E) ; (holding(Rob,E,S), A\=release(Rob,E))./* Defined Fluents */tableUp(S) :-val(vpos(end1,S),V1), V1>=3, val(vpos(end2,S),V2), V2>=3.safeToLift(Rob,Amount,Tol,S) :-tableEnd(E1), tableEnd(E2), E2\=E1, holding(Rob,E1,S),val(vpos(E1,S),V1), val(vpos(E2,S),V2),V1=<V2+Tol-Amount./* Initial state */val(vpos(end1,s0),0).val(vpos(end2,s0),0).tableEnd(end1).tableEnd(end2).*//* plus by CWA:/**//* not holding(rob1,_,s0) *//* not holding(rob2,_,s0) *//* Control procedures */proc(ctrl(Rob,Amount,Tol),seq(pick(e,seq(test(tableEnd(e)),act(grab(Rob,e)))),while(neg(tableUp(now)),seq(test(safeToLift(Rob,Amount,Tol,now)),act(vmove(Rob,Amount)))))).proc(jointLiftTable,conc(pcall(ctrl(rob1,1,2)), pcall(ctrl(rob2,1,2)))).Below we show a few final situations returned by the interpreter for the above example(note that the interpreter does not filter out identical situations).?- do(pcall(jointLiftTable),s0,S).S = do(vmove(rob2,1), do(vmove(rob1,1), do(vmove(rob2,1),do(vmove(rob1,1), do(vmove(rob2,1), do(grab(rob2,end2),do(vmove(rob1,1), do(vmove(rob1,1), do(grab(rob1,end1),s0))))))))) ;G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169147S = do(vmove(rob2,1), do(vmove(rob1,1), do(vmove(rob2,1),do(vmove(rob1,1), do(vmove(rob2,1), do(grab(rob2,end2),do(vmove(rob1,1), do(vmove(rob1,1), do(grab(rob1,end1),s0))))))))) ;S = do(vmove(rob1,1), do(vmove(rob2,1), do(vmove(rob2,1),do(vmove(rob1,1), do(vmove(rob2,1), do(grab(rob2,end2),do(vmove(rob1,1), do(vmove(rob1,1), do(grab(rob1,end1),s0)))))))))Yes9.2. Correctness of the Prolog implementationIn this section we prove the correctness of the interpreter presented above under suitableassumptions. Let C be the set of axioms for Trans, Final, and Do plus those needed forthe encoding of programs as first-order terms, and D the domain theory. To keep notationsimple we denote the condition corresponding to a situation calculus formula (cid:30) with thesituation argument replaced by now, simply by (cid:30). Similarly for Prolog terms correspondingto actions and programs.Our proof of correctness relies on the following assumptions:(cid:15) The domain theory D enforces the unique name assumption (UNA) on both actionsand objects. 16(cid:15) The predicate sub=4 correctly implements substitution for both programs andformulas.(cid:15) The predicate holds=2 satisfies the following properties:(1) If a goal holds.(cid:30); s/, with free variables only on object terms and action terms,succeeds with computed answer (cid:18) , then D jD 8(cid:30)TsU(cid:18) (by 8 , we mean theuniversal closure of ).(2) If a goal holds.(cid:30); s/, with free variables only on object terms and action terms,finitely fails, then D jD 8:(cid:30)TsU.(cid:15) The predicate poss=2 satisfies the following properties:(1) If a goal poss.a; s/, with free variables only on object terms and action terms,succeeds with computed answer (cid:18) then D jD 8Poss.a; s/(cid:18) .(2) If a goal poss.a; s/, with free variables only on object terms and action terms,finitely fails, then D jD 8:Poss.a; s/.(cid:15) The Prolog interpreter flounders (and hence does not return) on goals of the form nottrans.(cid:14); s; _; _/ 17 with nonground (cid:14) and s. 1816 UNA is already enforced for programs, see Appendix A.17 From a formal point of view not trans.(cid:14); s; _; _/ is a shorthand for not aux.(cid:14); s/ with aux=2 defined asaux.(cid:14); s/ V(cid:0) trans.(cid:14); s; _; _/.18 This form of floundering arises for example when we expand (cid:25) in programs of the form (cid:25) z:.(cid:14)1.z/ ii (cid:14)2.z//.Notably it does not arise for their variants (cid:25) z:.(cid:30).z/?I .(cid:14)1.z/ ii (cid:14)2.z///.148G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Observe that the hypotheses required for sub=4, holds=2 and poss=2 do hold whenthese predicates are defined as above and run by an interpreter that flounders on nongroundnegative goals (see [34]).Theorem 8. Under the hypotheses above the following holds:(1) If a goal do.(cid:14); s; s0/, where (cid:14) and s may contain variables only on object termsand action terms, succeeds with computed answer (cid:18) , then C [ D jD 8Do.(cid:14); s; s0/(cid:18) ,moreover s0(cid:18) may contain free variables only on object terms and action terms.(2) If a goal do.(cid:14); s; s0/, where (cid:14) and s may contain variables only on object terms andaction terms, finitely fails, then C [ D jD 8:Do.(cid:14); s; s0/.To make the arguments more apparent we will first prove the theorem withoutconsidering procedures. Then we show how introducing procedures affects the proof.Without proceduresTheorem 8 is an easy consequence of Lemmas 2 and 3 below.Lemma 2. Under the hypotheses above the following holds:(cid:15) The predicate trans=4 satisfies the following properties:(1) If a goal trans.(cid:14); s; (cid:14)0; s0/, where (cid:14) and s may contain variables only onobject terms and action terms, succeeds with computed answer (cid:18) , then C [ D jD8Trans.(cid:14); s; (cid:14)0; s0/(cid:18) , moreover (cid:14)0(cid:18) and s0(cid:18) may contain free variables only onobject terms and action terms.(2) If a goal trans.(cid:14); s; (cid:14)0; s0/, where (cid:14) and s may contain variables only on objectterms and action terms, finitely fails, then C [ D jD 8:Trans.(cid:14); s; (cid:14)0; s0/.(cid:15) The predicate final=2 satisfies the following properties:(1) If a goal final.(cid:14); s/, where (cid:14) and s may contain variables only on object termsand action terms, succeeds with computed answer (cid:18) , then C [ D jD 8Final.(cid:14); s/(cid:18) .(2) If a goal final.(cid:14); s/, where (cid:14) and s may contain variables only on object termsand action terms, finitely fails, then C [ D jD 8:Final.(cid:14); s/.Proof. First we observe that since we are not considering procedures, Trans and Finalsatisfy the axioms T and F from Sections 4 and 5. We prove simultaneously (1) and (2)for both trans=4 and final=2 by induction on the program (cid:14). Here we show only thecase (cid:14) D (cid:14)1 ii (cid:14)2 for trans=4.(ii) trans.(cid:14)1; s; _; _/ finitely fails and trans.(cid:14)2; s; (cid:14)0ii (cid:14)2/ is the most general unifier [23] between (cid:14)0 and (cid:14)01Success. If trans.(cid:14)1 ii (cid:14)2; s; (cid:14)0; s0/ succeeds with computed answer (cid:18) , then: either(i) trans.(cid:14)1; s; (cid:14)0mgu.(cid:14)0; (cid:14)011; s0/ succeeds with computed answer (cid:18)1, and (cid:18) D (cid:18) 0(cid:18)1 where (cid:18) 0 D2; s0/ succeeds with computed1; s0/(cid:18)1, and s0(cid:18)1 and (cid:14)0In case (i) by the induction hypothesis C [ D jD 8Trans.(cid:14)1; s; (cid:14)01(cid:18)1may contain free variables only on object terms and action terms. In case (ii) by the2; s0/(cid:18)2, and1; s0induction hypothesis C [ D jD 8:Trans.(cid:14)1; s; (cid:14)0s0(cid:18)2 and (cid:14)02(cid:18)2 may contain free variables only on object terms and action terms. Consideringanswer (cid:18)2 and (cid:18) D mgu.(cid:14)0; (cid:14)1 ii (cid:14)01/, C [ D jD 8Trans.(cid:14)2; s; (cid:14)0ii (cid:14)2; or2/(cid:18)2.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169149Trans.(cid:14)1 ii (cid:14)2; s; (cid:14)0; s0/ (cid:17)9(cid:13) :(cid:14)0 D .(cid:13) ii (cid:14)2/ ^ Trans.(cid:14)1; s; (cid:13) ; s0/ _9(cid:13) :(cid:14)0 D .(cid:14)1 ii (cid:13) / ^ Trans.(cid:14)2; s; (cid:13) ; s0/ ^ :9(cid:16); s00:Trans.(cid:14)1; s; (cid:16); s00/(3)and how (cid:18) is defined in both cases, we get the thesis.Failure. If trans.(cid:14)1 ii (cid:14)2; s; (cid:14)0; s0/ finitely fails, then:1 such that (cid:14)0 unifies with (cid:14)0(i) for all (cid:14)01; s0/ finitely fails, hence1; s0/ ^ (cid:14)0 D .(cid:14)0by the induction hypothesis C [ D jD 8:Trans.(cid:14)1; s; (cid:14)0(ii) either trans.(cid:14)1; s; _; _/ succeeds, hence C [ D jD 9(cid:14)01:Trans.(cid:14)1; s; (cid:14)01; s01/, or for2; s0/ finitely fails, hence by2, trans.(cid:14)2; s; (cid:14)02; s0/ ^ (cid:14)0 D .(cid:14)1 ii (cid:14)0all (cid:14)0the induction hypothesis C [ D jD 8:Trans.(cid:14)2; s; (cid:14)02 such that (cid:14)0 unifies with (cid:14)1 ii (cid:14)0ii (cid:14)2, trans.(cid:14)1; s; (cid:14)0ii (cid:14)2/;1; s0Considering (3) and the UNA for object, actions, and program terms, we get the thesis. 22/.11Lemma 3. Under the hypotheses above the following holds:(1) If a goal trans(cid:3).(cid:14); s; (cid:14)0; s0/, where (cid:14) and s may contain variables only onobject terms and action terms, succeeds with computed answer (cid:18) , then C [ D jD8Trans(cid:3).(cid:14); s; (cid:14)0; s0/(cid:18) , moreover (cid:14)0(cid:18) and s0(cid:18) may contain free variables only onobject terms and action terms.(2) If a goal trans(cid:3).(cid:14); s; (cid:14)0; s0/, where (cid:14) and s may contain variables only on objectterms and action terms, finitely fails, then C [ D jD 8:Trans(cid:3).(cid:14); s; (cid:14)0; s0/.Proof. Using Lemma 2. Success. Then there exists a successful SLDNF-derivation [23].Such a derivation must contain a finite number k of selected literals of the formtrans(cid:3).(cid:14)1; s1; (cid:14)2; s2/. The thesis is proven by induction on such a number k.Failure. Then there exists a finitely failed SLDNF-tree [23] formed by failed SLDNF-derivations each of which contains a finite number of selected literals of the formtrans(cid:3).(cid:14)1; s1; (cid:14)2; s2/. The thesis is proven by induction on the maximal number ofselected literals of the form trans(cid:3).(cid:14)1; s1; (cid:14)2; s2/ contained in the SLDNF-derivationsforming the tree. 2With proceduresSince we do not have nested procedures in the Prolog implementation, we can avoidcarrying around the procedure environment. Hence we can simplify the constraints onprocedures in the definition of Trans and Final from Section 7 to respectively:00T .P .Et /; s; (cid:14)F .P .Et/; s/ (cid:17) F; s/ (cid:17) T(cid:0)EvPEtTsU; s(cid:14)P(cid:0)EvP(cid:14)PEtTsU; s; (cid:14)(cid:1):(cid:1)0;0; sTo prove the soundness of the interpreter in presence of procedures, we need only redothe proof of Lemma 2.We now prove Lemma 2 as follows. Assume, for the moment, that Trans and Finalsatisfy the axioms T and F from Sections 4 and 5 plus the following ones:(cid:0)Trans.P .Et/; s; (cid:14)0; s0/ (cid:17) Trans(cid:0)EvPFinal.P .Et/; s/ (cid:17) FinalEt TsU; s(cid:14)PEvPEtTsU; s; (cid:14)0; s0:(cid:14)P(cid:1)(cid:1);150G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Then we follow the line of the proof given above. However we need to deal with theadditional complication that due to procedure expansions the program now does notget always simpler anymore. To this end, we observe that every terminating SLDNF-derivation contains a finite number of selected literals of the form trans.P .Et/; s1; (cid:14)2; s2/(final.P .Et/; s1/). Hence we can prove the lemma using the following three nestedinductions:(cid:15) Induction on the rank of successful SLDNF-derivations/finitely failed SLDNF-trees(i.e., the depth of nesting of auxiliary finitely failed SLDNF-trees) [23].(cid:15) Induction on the number of selected literals of the form trans.P .Et/; s1; (cid:14)2; s2/(final.P .Et/; s1/) occurring in a successful SLDNF-derivation, for success. Induc-tion on the maximal number of selected literals of the form trans.P .Et/; s1; (cid:14)2; s2/(final.P .Et/; s1/) contained in the SLDNF-derivations forming the finitely failedSLDNF-tree, for failure.(cid:15) Induction on the structure of the program.Now we come back to the assumption we made above for Trans and Final. In fact Final,being closed under the constraints on F in its definition, does actually satisfy the axiomsF from Sections 4 and 5 as well as the one above. However, Trans, which is not closedunder the constraints for T in its definition, does not satisfy the assumption, in general.However, we get the desired result by noticing that the equivalences assumed for Transform a conservative extension (see, e.g., [37]) of domain theory D plus the axioms neededfor the encoding of programs as first-order terms, and appealing to the following generalresult:Proposition 1. Let (cid:0) be a consistent theory, (cid:0) [ f(cid:8)g a conservative extension of (cid:0) where(cid:8) is a closed first-order formula, and P a predicate occurring in (cid:8) but not in (cid:0) . Then forany tuple of terms Et :(1) (cid:0) [ f(cid:8)g jD 8P .Et/ implies (cid:0) jD 8.8Z:T(cid:8)PZ(2) (cid:0) [ f(cid:8)g jD 8:P .Et/ implies (cid:0) jD 8.:8Z:T(cid:8)PZ(cid:27) Z.Et/U/,(cid:27) Z.Et/U/.Proof. (1) by contradiction. Suppose there exists a model M of (cid:0) and variable assignmentZ but M; (cid:27) 6jD Z.Et/. Now(cid:27) with (cid:27) .Z/ D R for some relation R, such that M; (cid:27) jD (cid:8)Pconsider the model M 0 of (cid:0) obtained from M by changing the interpretation of P toP M0 D R. Then M 0 jD (cid:8) and M 0; (cid:27) 6jD P .Et /, which contradicts (cid:0) [ f(cid:8)g jD 8P .Et/.(2) by contradiction. Suppose exists a model M of (cid:0) and a variable assignment (cid:27) such(cid:27) Z.Et/U. Then for every variable assignment (cid:27) 0 obtained from (cid:27)Z then M; (cid:27) 0 jD Z.Et/. Let M 0 be an expansion of Mwe have M; (cid:27) 0 jD Z.Et/, i.e., M 0; (cid:27) jD P .Et /, whichthat M; (cid:27) jD 8Z:T(cid:8)PZby putting (cid:27) .Z/ D Q if M; (cid:27) 0 jD (cid:8)Psuch that M 0 jD (cid:8). Then for Q D P M0contradicts (cid:0) [ f(cid:8)g jD 8:P .Et /. 2Intuitively, Proposition 1 says that when we constrain a relation P by a first-orderstatement, then every tuple that is forced to be “in” or “out” of the relation, will also besimilarly “in” or “out” of the relation obtained by the second-order version of the statement.Thus if Trans.(cid:14); s; (cid:14)0; s0/ holds for the first-order version of Trans, it must also hold for thesecond-order version.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–16915110. DiscussionWith all of this procedural richness (nondeterminism, concurrency, recursive procedures,priorities, etc.), it is important not to lose sight of the logical framework. ConGolog isindeed a programming language, but one whose execution, like planning, depends onreasoning about actions. Thus, a crucial part of a ConGolog program is the declarativepart: the precondition axioms, the successor state axioms, and the axioms characterizingthe initial state. This is central to how the language differs from superficially similar“procedural languages”. A ConGolog program together with the definition of Do andsome foundational axioms about the situation calculus is a formal logical theory aboutthe possible behaviors of an agent in a given environment. And this theory must be usedexplicitly by a ConGolog interpreter.In contrast, an interpreter for an ordinary procedural language does not use its semanticsexplicitly. Standard semantic accounts of programming languages also require the initialstate to be completely specified; our account does not; an agent may have to act withoutknowing everything about its environment. Our account accommodates domain-dependentprimitive actions and allows the interactions between the agent and its environment to bemodeled—actions may change the environment in a way that affects what actions can lateroccur [8].As mentioned, an important motivation for the development of ConGolog is the needfor tools to implement intelligent agent programs that are “reactive” in the sense thatthey reconsider their plans in response to significant changes in their environment. Thus,our work is related to earlier research on resource-bounded deliberative architecturessuch as [2] (IRMA) and [30] (PRS), and agent programming languages that are to someextent based on this kind of architectures, such as AGENT-0 [38], AgentSpeak(L) [29],and 3APL [16]. One difference is that in ConGolog, domain dynamics are specifieddeclaratively and the specification is used automatically in program execution; there is noneed to program the updating of a world model when actions are performed. On the otherhand, plan selection or generation is not specified using rules; it must be coded up in theprogram; this produces more complex programs, but there is perhaps less overhead. Finally,agents programmed in ConGolog can be understood as executing programs, albeit in asmart way; they have a simple operational semantics; architectures like IRMA and PRS,and languages like AGENT-0, AgentSpeak(L), and 3APL have more complex executionmodels.Other programming languages share features with ConGolog. The agent programminglanguage Concurrent MetateM [11] supports concurrency and uses a temporal logic tospecify the behavior of agents. Bonner and Kifer [3] have proposed a logical formalism tospecify concurrent database transactions. Also related are concurrent constraint languagessuch as CCP [35] and HCC [14], which support incompletely specified information statesand concurrency. But unlike ConGolog, these languages generally restrict the kinds ofconstraints allowed in order to make entailment easy to compute. In ConGolog, the actiontheory is what determines how how states are updated. Also in constraint languages, controlseems somewhat deemphasized. van Eijk et al. [10] have proposed an agent language partlyinspired from CCP.152G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Fig. 1. The ConGolog toolkit’s graphical viewer.The simple Prolog implementation of the ConGolog interpreter described in Section 8is at the core of a toolkit we have developed for implementing ConGolog applications. Theinterpreter in the toolkit is very similar to the one described, but uses a more convenientsyntax, performs some error detection, and has tracing facilities for debugging.The toolkit also includes a module for progressing the initial state database. Tounderstand the role of this component, first note that the basic method used by ourimplementation of action theories for determining whether a condition holds in a givensituation (i.e., evaluate holds.(cid:30); do.a1; : : : ; do.an; S0/ : : :/ is to perform regression onthe condition to obtain a new condition that only mentions the initial situation and thenquery the initial situation database to determine whether the new condition holds. Butregressing the condition all the way back to the initial situation can be quite inefficientwhen the program has been running for a while and many actions have been performed.If the program is willing to commit to a particular sequence of actions, it is possible toprogress the initial situation theory to a new initial situation theory representing the state ofaffairs after the sequence of actions. 19 Subsequent queries can then be efficiently evaluatedwith respect to this new initial situation database. The progression module performs thisupdating of the initial situation database.The toolkit also includes a graphical viewer (see Fig. 1) for debugging ConGologprograms and delivering process modeling applications. The tool, which is implementedin Tcl/Tk, displays the sequence of actions performed by the ConGolog program andthe value of the fluents in the resulting situation (or any situation along the path). The19 In general, the progression of an initial situation database may not be first-order representable; but whenthe initial situation is completely known (as we are assuming in this implementation), its progression is alwaysfirst-order representable and can be computed efficiently; see [22] for details.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169153program can be stepped through and exogenous events can be generated either manuallyor at random according to a given distribution. The manner in which state information isdisplayed can be specified easily and customized as required.Finally, a high-level Golog Domain Specification language (GDL) similar to Gelfondand Lifschitz’s A [12] has also been developed. The toolkit includes a GDL compiler thattakes a domain specification in GDL, generates successor state axioms for it, and thenproduces a Prolog implementation of the resulting domain theory.ConGolog has already been used in various applications. Lespérance et al. [19] haveimplemented a “reactive” high-level control module for a mobile robot in ConGolog. Therobot performs a mail-delivery task. The ConGolog control program involves a set ofprioritized interrupts that react to events such as the robot arriving to a customer’s mailboxor failing to get to a mailbox due to obstacles, as well as new shipment orders with varyingdegrees of urgency being received. The ConGolog controller was interfaced to navigationsoftware and successfully tested on a RWI B12 mobile robot.Work has also been done on using ConGolog to model multiagent systems [36]. In thiscase, the domain theory includes fluents that model the beliefs and goals of the system’sagents (this is done by adapting a possible-world semantics of such mental states to thesituation calculus). A ConGolog program is used to specify the complex behavior of theagents in such a system. A simple multiagent meeting scheduling example is specifiedin [36]. ConGolog-based tools for specifying and verifying complex multiagent systemsare being investigated.Finally, in [7], the transition semantics developed in this paper is adapted so thatexecution can be interleaved with program interpretation in order to accommodate sensingactions, that is, actions whose effect is not to change the world so much as to provideinformation to be used by the agent at runtime.In summary, we have seen how, given a basic action theory describing an initial state andthe preconditions and effects of a collection of primitive actions, it is possible to combinethese into complex actions for high-level agent control. The semantics of the resultinglanguage end up deriving directly from that of the underlying primitive actions. In thissense, the solution to the frame problem provided by successor state axioms for primitiveactions is extended to cover the complex actions of ConGolog. So ConGolog can be viewedas an action theory (that supports complex actions), as a specification language, and as animplementation language, and has been used in all three ways.There are, however, many areas for future research. Among them, we mention:handling non-termination, that is, developing accounts of program correctness (fairness,liveness etc.) appropriate for controllers expected to operate indefinitely as in [9], butwithout giving up the agent’s control over nondeterministic choices that characterizesthe Do-based semantics for terminating programs; and also incorporating utilities, so thatnondeterministic choices in execution can be made to maximize the expected benefit.AcknowledgementsThis research has been funded by the National Science and Engineering ResearchCouncil of Canada. We thank Koen Hindriks for interesting discussions about this work154G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169and for pointing out an error in an earlier version regarding situations other than nowappearing in primitive actions and tests. We also thank David Tremaine for alerting usto a problem with an earlier way of handling exogenous events in the semantics. Wethank David McAllester for pointing out the subtleties that arise in extending Golog andConGolog with boolean procedures. Finally, we thank the referees for their comments.Appendix A. Programs as termsIn this section, we develop an encoding of programs as first-order terms. Although somecare is required (e.g., introducing constants denoting variables and defining substitutionexplicitly in the language), this does not pose any major problem; see [18] for anintroduction to problems and techniques in this area.We add to the sorts Sit, Obj and Act of the Situation Calculus, the following new sorts:Idx, PseudoSit, PseudoAct, PseudoObj, PseudoForm, ENV, and PROG.Intuitively, elements of Idx denote natural numbers, and are used for building indexingfunctions. Elements of PseudoAct, PseudoObj, PseudoSit and PseudoForm are syntacticdevices to denote respectively actions, objects, situations and formulas within programs.Elements of ENV denote environments, i.e., sets of procedure definitions. And finally,elements of PROG denote programs, which are considered as simply syntactic objects.A.1. Sort IdxWe introduce the constant 0 of sort Idx, and a function succ : Idx ! Idx. For them weenforce the following unique name axioms:succ.i/ 6D 0;succ.i/ D succ.i0/ (cid:27) i D i0:We define the predicate Idx V Idx as:Idx.i/ (cid:17) 8X:T: : : (cid:27) X.i/U;where : : : stands for the conjunction of the universal closure ofX.0/;X.i/ (cid:27) X.succ.i//:Finally we assume the following domain closure axiom for sort Idx:8i:Idx.i/:A.2. Sorts PseudoSit, PseudoObj, PseudoActThe languages of PseudoSit, PseudoObj and PseudoAct are as follows:(cid:15) A constant Now V PseudoSit.(cid:15) A function nameOfSort : Sort ! PseudoSort for Sort D Obj; Act. We use the notationTTxUU to denote nameOfSort.x/, leaving Sort implicit.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169155(cid:15) A function varSort : Idx ! PseudoSort for Sort D Obj; Act. We call terms of the formvarSort.i/ pseudo-variables and we use the notation zi (or just x; y; z) to denotevarSort.i/, leaving Sort implicit.(cid:15) A function f : PseudoSort1 (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) PseudoSortn ! PseudoSortnC1 for each fluent ornonfluent function f of sort Sort1 (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) Sortn ! SortnC1 with Sorti D Obj; Act; Sitin the original language (note that if n D 0 then f is a constant).We define the predicates PseudoSit V PseudoSit, PseudoObj V PseudoObj andPseudoAct V PseudoAct respectively as:PseudoSit.x/ (cid:17) 8PSit; PObj; PAct:T: : : (cid:27) PSit.x/U;PseudoObj.x/ (cid:17) 8PSit; PObj; PAct:T: : : (cid:27) PObj.x/U;PseudoAct.x/ (cid:17) 8PSit; PObj; PAct:T: : : (cid:27) PAct.x/U;where : : : stands for the conjunction of the universal closure ofPSit.Now/;PSort.nameOfSort.x//for Sort D Obj; Act,for Sort D Obj; Act,PSort.x1/ ^ (cid:1) (cid:1) (cid:1) ^ PSort.xn/ (cid:27) PSort.f.x1 : : : ; xn//PSort.zi/(for each f):We assume the following domain closure axioms for the sorts PseudoSit, PseudoObjand PseudoAct:8x:PseudoSit.x/;8x:PseudoObj.x/;8x:PseudoAct.x/:We also enforce unique name axioms for them, that is, for all functions g; g0 of any arity(including constants) introduced above:g.x1; : : : ; xn/ 6D g0.y1; : : : ; ym/;g.x1; : : : ; xn/ D g.y1; : : : ; yn/ (cid:27) x1 D y1 ^ (cid:1) (cid:1) (cid:1) ^ xn D yn:Observe that the unique name axioms impose that nameOf.x/ D nameOf.y/ (cid:27) x D y butdo not say anything on domain elements denoted by x and y since these are elements ofAct or Obj.Next we want to relate pseudo-situations, pseudo-objects and pseudo-actions to realsituations, object and actions. In fact we do not want to relate all terms of sort PseudoObjand PseudoAct to real object and actions, but just the “closed” ones, i.e., those in which no156G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169pseudo variable zi occur. To formalize the notion of closedness, we introduce the predicateClosed V PseudoSort for Sort D Sit; Obj; Act, characterized by the following assertions 20Closed.Now/;Closed.nameOf.x//;:Closed.zi /;Closed.f.x1; : : : ; xn// (cid:17) Closed.x1/ ^ (cid:1) (cid:1) (cid:1) ^ Closed.xn/(for each f):Closed terms of sort PseudoObj and PseudoAct are related to real objects and actionsby means of the function decode V .PseudoSort (cid:2) Sit ! Sort/ for Sort D Sit; Obj; Act.We use the notation xTsU to denote decode.x; s/. Such a function is characterized by thefollowing assertions:decode.Now; s/ D s;decode.nameOf.x/; s/ D x;decode.f.x1 : : : ; xn/; s/ D f .decode.x1; s/; : : : ; decode.xn; s//(for each f).A.3. Sort PseudoFormNext we introduce pseudo-formulas used in tests. Specifically, we introduce:(cid:15) A function p : PseudoSort1 (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) PseudoSortn ! PseudoForm for each nonflu-ent/fluent predicate p in the original language (not including the new the predicatesintroduced in this section).(cid:15) A function and : PseudoForm (cid:2) PseudoForm ! PseudoForm. We use the notation(cid:15) A function not : PseudoForm ! PseudoForm. We use the notation :(cid:26) to denote(cid:26)1 ^ (cid:26)2 to denote and.(cid:26)1; (cid:26)2/.not.(cid:26)/.(cid:15) A function someSort : PseudoSort (cid:2) PseudoForm ! PseudoForm, for PseudoSort DPseudoObj; PseudoAct. We use the notation 9zi :(cid:26) to denote some.varSort.i/; (cid:26)/,leaving Sort implicit.We define the predicate PseudoForm V PseudoForm as:PseudoForm.(cid:26)/ (cid:17) 8PForm:T: : : (cid:27) PForm.(cid:26)/Uwhere : : : stands for the conjunction of the universal closure ofPForm.p.x1; : : : ; xn//(for each p),PForm.(cid:26)1/ ^ PForm.(cid:26)2/ (cid:27) PForm.(cid:26)1 ^ (cid:26)2/;PForm.(cid:26)/ (cid:27) PForm.:(cid:26)/;PForm.(cid:26)/ (cid:27) PForm.9zi :(cid:26)/:20 We say the following theory is “characterizing” since it is complete, in the sense that it partitions the elementsin PseudoSort into those that are closed and those that are not.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169157We assume the following domain closure axiom for the sort PseudoForm:8(cid:26):PseudoForm.(cid:26)/:We also enforce unique name axioms for pseudo-formulas, that is, for all functions g; g0 ofany arity introduced above:g.x1; : : : ; xn/ 6D g0.y1; : : : ; ym/;g.x1; : : : ; xn/ D g.y1; : : : ; yn/ (cid:27) x1 D y1 ^ (cid:1) (cid:1) (cid:1) ^ xn D yn:Next we formalize the notion of substitution. We introduce the function sub :PseudoSort (cid:2) PseudoSort (cid:2) PseudoSort 0 ! PseudoSort 0 for Sort D Obj; Act and Sort 0 DSit; Obj; Act. We use the notation t xy to denote sub.x; y; t/. Such a function is character-ized by the following assertions:D nameOf.t/;NowxD Now;ynameOf.t/xyD y;zixx 6D zi (cid:27) ziyf.t1; : : : ; tn/xyziyD zi ;D f.t1xy ; : : : ; tnxy/(for each f):We extend the function sub to pseudo-formulas (as third argument) as follows:xy/(for each p);xy ; : : : ; tn^ .(cid:26)2/xy;D p.t1p.t1; : : : ; tn/xyD .(cid:26)1/x.(cid:26)1 ^ (cid:26)2/xyy.:(cid:26)/xD :.(cid:26)/xy;yD 9zi :(cid:26);.9zi :(cid:26)/ziyx 6D zi (cid:27) .9zi :(cid:26)/xyD 9zi :.(cid:26)xy /:Next we extend the predicate Closed to pseudo-formulas in a natural way:Closed.p.x1; : : : ; xn// (cid:17) Closed.x1/ ^ (cid:1) (cid:1) (cid:1) ^ Closed.xn/Closed.(cid:26)1 ^ (cid:26)2/ (cid:17) Closed.(cid:26)1/ ^ Closed.(cid:26)2/;Closed.:(cid:26)/ (cid:17) Closed.(cid:26)1/;Closed.9zi :(cid:26)/ (cid:17) 8y:Closed.(cid:26)zinameOf.y//:(for each p);We relate closed pseudo-formulas to real formulas by introducing a predicate Holds VPseudoForm (cid:2) Sit, characterized by the following assertions:Holds.p.x1; : : : ; xn/; s/ (cid:17) p.decode.x1; s/; : : : ; decode.xn; s//(for each p);Holds.(cid:26)1 ^ (cid:26)2; s/ (cid:17) Holds.(cid:26)1; s/ ^ Holds.(cid:26)2; s/;Holds.:(cid:26); s/ (cid:17) :Holds.(cid:26); s/;Holds.9z:(cid:26); s/ (cid:17) 9y:Holds.(cid:26)znameOf.y/; s/;where y in the last equation is any variable that does not appear in (cid:26). We use the notation(cid:30)TsU to denote Holds.(cid:30); s/.158G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169A.4. Sorts PROG and ENVNow we are ready to introduce programs. Specifically, we introduce:(cid:15) A constant nil V PROG.(cid:15) A function act : PseudoAct ! PROG. As notation we write simply a to denoteact.a/ when confusion cannot arise.(cid:15) A function test : PseudoForm ! PROG. We use the notation (cid:26)? to denotetest.(cid:26)/.(cid:15) A function seq : PROG (cid:2) PROG ! PROG. We use the notation (cid:14)1I (cid:14)2 to denoteseq.(cid:14)1; (cid:14)2/.(cid:15) A function choice : PROG (cid:2) PROG ! PROG. We use the notation (cid:14)1 j (cid:14)2 to denotechoice.(cid:14)1; (cid:14)2/.(cid:15) A function iter : PROG ! PROG. We use the notation (cid:14)(cid:3) to denote iter.(cid:14)/.(cid:15) Two functions pickSort : PseudoSort (cid:2) PROG ! PROG, where PseudoSort is eitherPseudoObj or PseudoAct. We use the notation (cid:25) zi:(cid:14) to denote pickSort.varSort.i/;(cid:14)/, leaving Sort implicit.(cid:15) A function if : PseudoForm (cid:2) PROG (cid:2) PROG ! PROG. We use the notation if (cid:26)then (cid:14)1 else (cid:14)2 to denote if.(cid:26); (cid:14)1; (cid:14)2/.(cid:15) A function while : PseudoForm (cid:2) PROG ! PROG. We use the notation while (cid:26)do (cid:14) to denote while.(cid:26); (cid:14)/.(cid:15) A function conc : PROG (cid:2) PROG ! PROG. We use the notation (cid:14)1 k (cid:14)2 to denoteconc.(cid:14)1; (cid:14)2/.(cid:15) A function prconc : PROG(cid:2)PROG ! PROG. We use the notation (cid:14)1 ii (cid:14)2 to denoteprconc.(cid:14)1; (cid:14)2/.(cid:15) A function iterconc : PROG ! PROG. We use the notation (cid:14)jjto denoteiterconc.(cid:14)/.To deal with procedures we need to introduce the notion of environment together withthat of program. We introduce:(cid:15) A finite number of functions P : PseudoSort1 (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) PseudoSortn ! PROG, wherePseudoSorti is either PseudoObj or PseudoAct. These functions are going to be usedas procedure calls.(cid:15) A function proc : PROG(cid:2) PROG ! PROG. This function is used to build proceduredefinitions and so we will force the first argument to have the form P.zi1; : : : ; zin/,where z1 : : : zn are used to denote the formal parameters of the defined procedure. Weuse the notation proc P.z1; : : : ; zn/ (cid:14) end to denote proc.P.z1; : : : ; zn/; (cid:14)/.(cid:15) A constant " V ENV, denoting the empty environment.(cid:15) A function addproc : ENV (cid:2) PROG ! ENV. We will restrict the programs allowedto appear as the second argument to procedure definitions only. We use the notationEI proc P.Ez/ (cid:14) end to denote addproc.E; proc P.Ez/ (cid:14) end/.(cid:15) A function pblock : ENV (cid:2) PROG ! PROG. We use the notation fEI (cid:14)g to denotepblock.E; (cid:14)/.(cid:15) A function c_call : ENV (cid:2) PROG ! PROG. We will restrict the programs allowedto appear as the second argument to procedure calls only. We use the notationTE V P.Et/U to denote c_call.E; P.Et//.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169159We next introduce a predicate defined V PROG (cid:2) ENV meaning that a procedure isdefined in an environment. It is specified as:defined.c; E/ (cid:17) 8D:T: : : (cid:27) D.c; E/U;where : : : stands for the conjunction of the universal closure ofD.P.Ex/; "I proc P.Ey/ (cid:14) end/;D.c; E 0/ (cid:27) D.c; E 0I d/:Observe that procedures P are only defined in an environment E, and that the parametersthe procedure is applied to do not play any role in determining whether the procedure isdefined.Now we define the predicate Prog V PROG and the predicate Env V ENV as:Prog.(cid:14)/ (cid:17) 8PPROG; PENV :T : : : (cid:27) PPROG.(cid:14)/U;Env.E/ (cid:17) 8PPROG; PENV :T : : : (cid:27) PENV .E/U;where : : : stands for the universal closure ofPPROG.nil/;PPROG.act.a//(a pseudo-action);PPROG.(cid:26)?/((cid:26) pseudo-formula);PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.(cid:14)1I (cid:14)2/;PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.(cid:14)1 j (cid:14)2/;PPROG.(cid:14)/ (cid:27) PPROG.(cid:14)(cid:3)/;PPROG.(cid:14)/ (cid:27) PPROG.(cid:25) zi:(cid:14)/;PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.if (cid:26) then (cid:14)1 else (cid:14)2/;PPROG.(cid:14)/ (cid:27) PPROG.while (cid:26) do (cid:14)/;PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.(cid:14)1 k (cid:14)2/;PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.(cid:14)1 ii (cid:14)2/;PPROG.(cid:14)/ (cid:27) PPROG.(cid:14)jj/;(for each P);PPROG.P.x1; : : : ; xn//PENV .E/ ^ PPROG.(cid:14)/ (cid:27) PPROG.fEI (cid:14)g/;PENV .E/ ^ defined.P.Ez/; E/ (cid:27) PPROG.TE V P.x1; : : : ; xn/U/;PENV ."/;PENV .E/ ^ PPROG.(cid:14)/ ^ :defined.P.Ez/; E/ ^!zih6D zik(cid:27)n^h;kD1PENV .EI proc P.zi1; : : : ; zin / (cid:14) end/: 160G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169We assume the following domain closure axioms for the sorts PROG and ENV:8(cid:14):Prog.(cid:14)/;8E:Env.E/:We also enforce unique name axioms for programs and environments, that is for allfunctions g; g0 of any arity introduced above:g.x1; : : : ; xn/ 6D g0.y1; : : : ; ym/;g.x1; : : : ; xn/ D g.y1; : : : ; yn/ (cid:27) x1 D y1 ^ (cid:1) (cid:1) (cid:1) ^ xn D yn:We extend the predicate Closed to PROG by induction on the structure of the programterms in the obvious way so as to consider closed, programs in which all occurrences ofpseudo-variables zi are bound either by (cid:25) , or by being a formal parameter of a procedure.Only closed programs are considered legal.We introduce the function resolve : ENV (cid:2) PROG (cid:2) PROG ! PROG, to be used toassociate to procedure calls the environment to be used to resolve them. Namely, given theprocedure P defined in the environment E, resolve.E; P.Et/; (cid:14)/ denoted by .(cid:14)/P.Et/TEVP.Et/U,suitably replaces P.Et/ by c_call.E; P.Et// in order to obtain static scope for procedures.It is obvious how the function can be extended to resolve whole sets of procedure callswhose procedures are defined in the environment E. Formally this function satisfies thefollowing assertions:.nil/P.Ex/TEVP.Ex/U D nil;.a/P.Ex/TEVP.Ex/U D a;.(cid:26)?/P.Ex/TEVP.Ex/U D (cid:26)?;TEVP.Ex/U;TEVP.Ex/U;.(cid:14)1I (cid:14)2/P.Ex/.(cid:14)1 j (cid:14)2/P.Ex/.(cid:25) zi :(cid:14)/P.Ex/TEVP.Ex/UI .(cid:14)2/P.Ex/TEVP.Ex/U j .(cid:14)2/P.Ex/TEVP.Ex/U D .(cid:14)1/P.Ex/TEVP.Ex/U D .(cid:14)1/P.Ex/TEVP.Ex/U D (cid:25) zi:.(cid:14)/P.Ex/TEVP.Ex/U;(cid:0)(cid:1)(cid:3).(cid:14)/P.Ex/;.(cid:14)(cid:3)/P.Ex/TEVP.Ex/U DTEVP.Ex/U.if (cid:26) then (cid:14)1 else (cid:14)2/P.Ex/TEVP.Ex/U D if (cid:26) then .(cid:14)1/P.Ex/TEVP.Ex/U else .(cid:14)2/P.Ex/TEVP.Ex/U;.while (cid:26) do (cid:14)/P.Ex/.(cid:14)1 k (cid:14)2/P.Ex/TEVP.Ex/U;TEVP.Ex/U D while (cid:26) do .(cid:14)/P.Ex/TEVP.Ex/U k .(cid:14)2/P.Ex/TEVP.Ex/U ii .(cid:14)2/P.Ex/TEVP.Ex/U D .(cid:14)1/P.Ex/TEVP.Ex/U D .(cid:14)1/P.Ex/TEVP.Ex/U;TEVP.Ex/U;.(cid:14)1 ii (cid:14)2/P.Ex/P.Ex/TEVP.Ex/U D ..(cid:14)/P.Ex/.(cid:14)/jjTEVP.Ex/U/jj;G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169161.P.Ex//P.Ex/.Q.Et//P.Ex/TEVP.Ex/U D TE V P.Ex/U;TEVP.Ex/U D Q.Et/8<.fE 0I (cid:14)g/P.Ex/TEVP.Ex/U D:for any procedure call Q.Et/ different from P.Ex/;fE 0I (cid:14)g(cid:8)E 0I .(cid:14)/P.Ex/TEVP.Ex/Uif procedure P is (re)defined in E 0;(cid:9)otherwise;.TE 0 V Q.EtU//P.Ex/TEVP.Ex/U D TE 0 V Q.Et/U for every procedure call Q.Et/ and environment E 0:Finally, we extend the function sub to PROG (as third argument) again by induction onthe structure of program terms in the natural way considering (cid:25) as a binding construct forpseudo-variables and without doing any substitutions into environments. sub is used forsubstituting formal parameters with actual parameters in contextualized procedure calls, aswell as to deal with (cid:25) . We also introduce a function c_body : PROG (cid:2) ENV ! PROG tobe used to return the body of the procedures. Namely, c_body.P.Ex/; E/ returns the bodyof the procedure P in E with the formal parameters substituted by the actual parameters Ex.Formally this function satisfies the following assertions:c_body.P.Ex/; EI proc P.Ey/ (cid:14) end/ D (cid:14)c_body.P.Ex/; EI proc Q.Ey/ (cid:14) end/ D c_body.P.Ex/; E/EyEx ;.Q 6D P/:A.5. Consistency preservationThe encoding presented here preserves consistency as stated by the following theorem.Theorem A.1. Let H be the axioms defining the encoding above. Then every model of anaction theory D (involving sorts Sit, Act and Obj) can be extended to a model of H [ D(involving the additional sorts Idx, PseudoSit, PseudoAct, PseudoObj, PseudoForm, ENVand PROG).Proof. It suffices to observe that for each new sort (Idx; : : : ; PROG) H contains:(cid:15) A second-order axiom that explicitly defines a predicate which inductively character-izes the elements of the sort.(cid:15) An axiom that closes the domain of the new sort with respect to the characterizingpredicate.(cid:15) Unique name axioms that extend the interpretation of D to the new sort by inductionon the structure of the elements (as imposed by the characterizing axiom).(cid:15) Axioms that characterize predicates and functions, such as Closed, decode, sub,Holds, etc., by induction on the structure of the elements of the sort.Hence, given a model M of the action theory D, it is straightforward to introduce domainsfor the new sorts that satisfy the characterizing predicate, the domain closure axioms, andthe unique name axioms for the sort, by proceeding by induction on the structure of theelements forced by the characterizing predicate, and then establishing the extension of thenewly defined predicates/functions for the sort. 2162G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Appendix B. Proof of Theorem 1—Equivalence between the Do’s for GologprogramsIn this section, we prove Theorem 1, i.e., the equivalence of the original definition ofDo and the new one given in this paper, in the more general language which includesprocedures. To simplify the presentation of the proof, we use the same symbols to denoteterms and elements of the domain of interpretation; the meaning will be clear from thecontext.B.1. Alternative definitions of Trans and FinalFor proving the following results, it is convenient to reformulate the definitions of Transand Final:(cid:15) Trans.(cid:14); s; (cid:14)0; s0/ (cid:17) 8T :T : : : (cid:27) T .(cid:14); s; (cid:14)0; s0/U, where : : : stands for the conjunctionof the universal closure of the following implications:Poss.aTsU; s/ (cid:27) T .a; s; nil; do.aTsU; s//;(cid:30)TsU (cid:27) T .(cid:30)?; s; nil; s/;0I (cid:13) ; s0/ (cid:27) T .(cid:14)I (cid:13) ; s; (cid:14); sFinal.(cid:13) ; s/ ^ T .(cid:14); s; (cid:14)0; s0/ (cid:27) T .(cid:13) I (cid:14); s; (cid:14)0; s0/;000T .(cid:14); s; (cid:14)/;000; s; s/ (cid:27) T .(cid:14) j (cid:13) ; s; (cid:14)/;T .(cid:14); s; (cid:14)T .(cid:14); s; (cid:14)0; s0/ (cid:27) T .(cid:13) j (cid:14); s; (cid:14)0; s0/;x ; s; (cid:14)0; s0/ (cid:27) T .(cid:25)v:(cid:14); s; (cid:14)0; s0/;T .(cid:14)vT .(cid:14); s; (cid:14)0; s0/ (cid:27) T .(cid:14)(cid:3); s; (cid:14)0I (cid:14)(cid:3); s0/;(cid:0)(cid:14)Pi .Et/TEnvVPi .Et/U; s; (cid:14)0; s0T(cid:0)EvPg; s; (cid:14)0; s0fEnvI (cid:14)PEtTsU(cid:1)(cid:1)T(cid:27) T .fEnvI (cid:14)g; s; (cid:14)0; s0/;(cid:27) T .TEnv V P .Et/U; s; (cid:14)0; s0/:(cid:15) Final.(cid:14); s/ (cid:17) 8F:T: : : (cid:27) F .(cid:14); s/U, where : : : stands for the conjunction of theuniversal closure of the following implications:True (cid:27) F .nil; s/;F .(cid:14); s/ ^ F .(cid:13) ; s/ (cid:27) F .(cid:14)I (cid:13) ; s/;F .(cid:14); s/ (cid:27) F .(cid:14) j (cid:13) ; s/;F .(cid:14); s/ (cid:27) F .(cid:13) j (cid:14); s/;F .(cid:14)vx ; s/ (cid:27) F .(cid:25)v:(cid:14); s/;True (cid:27) F .(cid:14)(cid:3)(cid:0)(cid:14)Pi .Et/TEnvVPi .Et/U; sF(cid:0)EvPfEnvI (cid:14)PEt TsU; sF(cid:1)(cid:1); s/;(cid:27) F .fEnvI (cid:14)g; s/;(cid:27) F .TEnv V P .Et/U; s/:G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169163Theorem B.1. With respect to Golog programs, the definitions above are equivalent to theones given in Section 7 of the paper.Proof. To prove this equivalence, consider first the following general results, which are adirect consequence of the Tarski–Knaster fixpoint theorem [40]. IfS.Ex/ (cid:17) 8Z:TT8Ey:(cid:8).Z; Ey/ (cid:27) Z.Ey/U (cid:27) Z.Ex/Uand (cid:8).Z; Ey/ is monotonic, i.e.,8Z1; Z2:T8Ey:Z1.Ey/ (cid:27) Z2.Ey/U (cid:27) T8Ey:(cid:8).Z1; Ey/ (cid:27) (cid:8).Z2; Ey/U;then we get the following consequences 21S.Ex/ (cid:17) (cid:8).S; Ex/;S.Ex/ (cid:17) 8Z:TT8Ey:Z.Ey/ (cid:17) (cid:8).Z; Ey/U (cid:27) Z.Ex/U:(B.1)(B.2)(B.3)Now it is easy to see that the above definition of Trans and Final can be rewritten as (B.1)and that the resulting (cid:8) is indeed monotonic (in particular it is syntactically monotonicsince the predicate variables T and F do not occur in the scope of any negation). Thus,by the Tarski–Knaster fixpoint theorem, the above definitions can be rewritten in the formof (B.3). Once in this form it is easy to see that for Golog programs they are equivalent tothose introduced in Section 7. 2B.2. Do1 is equivalent to Do2Let Do1 be the original definition of Do in [20] extended with Do1.nil; s; s0/defD s0 D sdefD Do.fEnvI P .Et/g; s; s0/, and Do2 the new definition inand Do.TEnv V P .Et /U; s; s0/terms of Trans and Final. Also, we do not allow procedure calls for which no proceduredefinitions are given.Lemma B.1. For every model M of C, there exist (cid:14)1; s1 : : : (cid:14)n; sn such that M jD Trans.(cid:14)i;si; (cid:14)iC1; siC1/ for i D 1; : : : ; n (cid:0) 1 if and only if M jD Trans(cid:3).(cid:14)1; s1; (cid:14)n; sn/.Proof. ()) By induction on n. If n D 1, then M jD Trans(cid:3).(cid:14)1; s1; (cid:14)1; s1/ by definitionof Trans(cid:3). If n > 1, then by induction hypothesis M jD Trans(cid:3).(cid:14)2; s2; (cid:14)n; sn/, and sinceM jD Trans.(cid:14)1; s1; (cid:14)2; s2/, we get M jD Trans(cid:3).(cid:14)1; s1; (cid:14)n; sn/ by definition of Trans(cid:3).(() Let R be the relation formed by the tuples .(cid:14)1; s1; (cid:14)n; sn/ such that there exist(cid:14)1; s1 : : : (cid:14)n; sn and M jD Trans.(cid:14)i; si; (cid:14)iC1; siC1/ for i D 1; : : : ; n (cid:0) 1. It is easy to verifythat(i) for all (cid:14); s, .(cid:14); s; (cid:14); s/ 2 R;(ii) for all (cid:14); s; (cid:14)0; s0; (cid:14)00; s00, M jD Trans.(cid:14); s; (cid:14)0; s0/ and .(cid:14)0; s0; (cid:14)00; s00/ 2 R implies.(cid:14); s; (cid:14)00; s00/ 2 R. 221 In fact, (B.2) is only mentioned in passing and not used in the proof.164G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Lemma B.2. For every model M of C, M jD Do1.(cid:14); s; s0/ implies that there exist (cid:14)1; s1;: : : ; (cid:14)n; sn such that (cid:14)1 D (cid:14), s1 D s, sn D s0, M jD Final.(cid:14)n; sn/, and M jD Trans.(cid:14)i; si ;(cid:14)iC1; siC1/ for i D 1; : : : ; n (cid:0) 1.Proof. We prove the lemma by induction on the structure of the program. We only givedetails for the most significant cases.(1) a (atomic action). M jD Do1.a; s; s0/ iff M jD Poss.aTsU; s/ and s0 D do.aTsU; s/.Then M jD Trans.a; s; nil; do.aTsU; s//, and hence the thesis.(2) (cid:14)I (cid:13) (sequence). M jD Do1.(cid:14)I (cid:13) ; s; s0/ iff M jD Do1.(cid:14); s; s00/ and M jD Do1.(cid:13) ; s00;s0/. Then by induction hypothesis:(i) there exist (cid:14)1; s1 : : : ; (cid:14)k; sk such that (cid:14)1 D (cid:14), s1 D s, sk D s00, M jD Final.(cid:14)k; sk/and M jD Trans.(cid:14)i; si ; (cid:14)iC1; si / for i D 1; : : : ; k (cid:0) 1;(ii) there exist (cid:13)k; sk : : : ; (cid:13)n; sn such that (cid:13)1 D (cid:13) , sk D s00, sn D s0, M jD Final.(cid:13)n; sn/and M jD Trans.(cid:13)i; si ; (cid:13)iC1; si / for i D k; : : : ; n (cid:0) 1.Since Trans itself is closed under the assertions in its definition we have that: M jDTrans.(cid:14)i; si ; (cid:14)iC1; siC1/ implies M jD Trans.(cid:14)iI (cid:13) ; si; (cid:14)iC1I (cid:13) ; siC1/. Moreover M jDFinal.(cid:14)k; sk/ and M jD Trans.(cid:13)k; sk; (cid:13)kC1; skC1/ implies M jD Trans.(cid:14)kI (cid:13)k; sk;(cid:13)kC1; skC1/. Similarly in the case k D n we have that, since Final is also closed underthe assertions in its definition M jD Final.(cid:14)k; sk/ and M jD Final.(cid:13)k; sk/ impliesM jD Final.(cid:14)kI (cid:13)k; sk/. Hence the thesis.(3) (cid:14)(cid:3) (iteration). M jD Do1.(cid:14)(cid:3); s; s0/ iff M jD 8P :T: : : (cid:27) P .s; s0/U where : : : stand forthe following two assertions:(i) 8s:P .s; s/;(ii) 8s; s0; s00:Do1.(cid:14); s; s00/ ^ P .s00; s0/ (cid:27) P .s; s0/.Consider the relation Q defined as the set of pairs .s; s0/ such that: there exist(cid:14)1; s1 : : : ; (cid:14)n; sn with (cid:14)1 D (cid:14)(cid:3), s1 D s, sn D s0, M jD Final.(cid:14)n; sn/ and M jDTrans.(cid:14)i; si ; (cid:14)iC1; si / for i D 1; : : : ; n (cid:0) 1. To prove the thesis, it is sufficient to showthat Q satisfies the two assertions (i) and (ii).(i) Let (cid:14)1 D (cid:14)n D (cid:14)(cid:3), s1 D sn D s; since M jD Final.(cid:14)(cid:3); s/, it follows that for all s,.s; s/ 2 Q.(ii) By the first induction hypothesis (the induction on the structure of the program):M jD Do1.(cid:14); s; s00/ implies that there exist (cid:14)1; s1 : : : ; (cid:14)k; sk such that (cid:14)1 D(cid:14), s1 D s, sk D s00, M jD Final.(cid:14)k; sk/ and M jD Trans.(cid:14)i; si ; (cid:14)iC1; siC1/ fori D 1; : : : ; k (cid:0) 1. This implies that M jD Trans.(cid:14)iI (cid:14)(cid:3); si; (cid:14)iC1I (cid:14)(cid:3); siC1/ fori V 2; : : : ; k (cid:0) 1. Moreover, we must also have M jD Trans.(cid:14)(cid:3); s1; (cid:14)2I (cid:14)(cid:3); s2/.By the second induction hypothesis (rule induction for P ), we can assumethat there exist (cid:13)k; sk : : : ; (cid:13)n; sn such that (cid:13)k D (cid:14)(cid:3), sk D s00, sn D s0, M jDFinal.(cid:13)n; sn/ and M jD Trans.(cid:13)i; si ; (cid:13)iC1; siC1/ for i D k; : : : ; n (cid:0) 1.Now observe that Final.(cid:14)k; sk/ and Trans.(cid:13)k; sk; (cid:13)kC1; skC1/ implies thatTrans.(cid:14)kI (cid:13)k; sk; (cid:13)kC1; skC1/. Thus, we get that (ii) holds for Q.Hence the thesis.(4) fEnvI (cid:14)g (procedures). M jD Do1.fEnvI (cid:14)g; s; s0/ iffM jD 8P1; : : : ; Pn: T(cid:8) (cid:27) Do1.(cid:14); s; s0/U;G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169165where(cid:8) D"n^iD18Ex; s; s0:Do1.(cid:14)i0EviEx ; s; s/ (cid:27) Pi .Ex; s; s0/:#To get the thesis, it suffices to prove it for the case:M jD 8P1; : : : ; Pn: T(cid:8) (cid:27) Pi .Ex; s; s0/U(B.4)(B.5)and then apply the induction argument on the structure of the program consideringas base cases nil, a, (cid:30)?, and P .Et/.Consider the relations Qi defined as the set of tuples .Ex; s; s0/ such that there exist(cid:14)1; s1 : : : ; (cid:14)n; sn with (cid:14)1 D fEnvI Pi.Ex/g, 22 s1 D s, sn D s0, M jD Final.(cid:14)n; sn/ andM jD Trans.(cid:14)i; si ; (cid:14)iC1; si / for i D 1; : : : ; n (cid:0) 1. To prove the thesis it is sufficient toshow that each Qi satisfies (is closed under) the assertion (B.4).defD Pi .Ex; s; s0/ where Pi is a free predicate variable.Recall that Do1.Pi .Ex//; s; s0/jD Do1.Pi .Ex/; s; s0/This means that for any variable assignment (cid:27) , M; (cid:27) P1;:::;PnQ1;:::;Qnimplies .Ex; s; s0/ 2 Qi , i.e., there exist (cid:14)1; s1 : : : ; (cid:14)n; sn with (cid:14)1 D fEnvI Pi.Ex/g, s1 Ds, sn D s0, M jD Final.(cid:14)n; sn/ and M jD Trans.(cid:14)i; si; (cid:14)iC1; si / for i D 1; : : : ; n (cid:0) 1.Hence by induction on the structure of the program, considering as base cases nil,EviEx ; s; s0/ implies that therea, (cid:30)? and P .Et /, we have that M; (cid:27) P1;:::;PnQ1;:::;QnEvig, s1 D s, sn D s0, M jD Final.(cid:14)n; sn/exist (cid:14)1; s1 : : : ; (cid:14)n; sn with (cid:14)1 D fEnvI (cid:14)iExand M jD Trans.(cid:14)i; si; (cid:14)iC1; si / for i D 1; : : : ; n (cid:0) 1. Now considering that M jDg; s1; (cid:14)2; s2/ implies M jD Trans.TEnv V Pi .Ex/U; s1; (cid:14)2; s2/ impliesTrans.fEnvI (cid:14)iM jD Trans.fEnvI Pi.Ex/g; s1; (cid:14)2; s2/, we get that .Ex; s; s0/ 2 Qi . 2jD Do1.(cid:14)iEviExLemma B.3. For all Golog programs (cid:14) and situations s:Final.(cid:14); s/ (cid:27) Do1.(cid:14); s; s/:Proof. It is easy to show that Do1.(cid:14); s; s/ is closed with respect to the implications in theinductive definition of Final. 2Lemma B.4. For all Golog programs (cid:14); (cid:14)0 and situations s; s0:Trans.(cid:14); s; (cid:14)0; s0/ ^ Do1.(cid:14)0; s0; s00/ (cid:27) Do1.(cid:14); s; s00/:Proof. The property we want to prove can be rewritten as follows:Trans.(cid:14); s; (cid:14)0; s0/ (cid:27) (cid:8).(cid:14); s; (cid:14)0; s0/with(cid:8).(cid:14); s; (cid:14)0; s0/defD 8s00:Do1.(cid:14)0; s0; s00/ (cid:27) Do1.(cid:14); s; s00/:22 To be more precise, the variables xi in Pi .Ex/ should be read as nameOf.xi / thus converting situation calculusobjects/actions variables into suitable program terms (see Appendix A).166G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169Hence it is sufficient to show that (cid:8) is closed under the implications that inductively defineTrans. Again, we only give details for the most significant cases.(1) Implication for primitive actions. We show that Poss.aTsU; s/ (cid:27) (cid:8).aTsU; s; nil;do.aTsU; s//, i.e.:Poss.aTsU; s/ (cid:27) 8s00:Do1.nil; do.aTsU; s/; s00/ (cid:27) Do1.a; s; s00/:Since Do1.nil; s; s0/which holds by the definition of Do1.defD s0 D s, this reduces to Poss.aTsU; s/ (cid:27) Do1.a; s; do.a; s//,(2) First implication for sequences. We have to show (cid:8).(cid:14); s; (cid:14)0; s0/ (cid:27) (cid:8).(cid:14)I (cid:13) ; s; (cid:14)0; s0/,i.e.:8s00:TDo1.(cid:14)0; s0; s00/ (cid:27) Do1.(cid:14); s; s00/U (cid:27)8s00:Do1.(cid:14)0I (cid:13) ; s0; s00/ (cid:27) Do1.(cid:14)I (cid:13) ; s; s00/:By contradiction. Suppose that there is a model M such that M jD 8s00:Do1.(cid:14)0; s0;s00/ (cid:27) Do1.(cid:14); s; s00/, and M jD Do1.(cid:14)0I (cid:13) ; s0; sc/ and M jD :Do1.(cid:14)I (cid:13) ; s; sc/ forsome sc. This means that M jD Do1.(cid:14)0; s0; st / ^ Do1.(cid:13) ; st ; sc/ for some st , butM jD 8t::Do1.(cid:14); s; t/ _ :Do1.(cid:13) ; t; sc/. Since M jD Do1.(cid:14)0; s0; st / implies M jDDo1.(cid:14); s; st /, we have a contradiction.(3) Second implication for sequences. We have to show Final.(cid:14); s/ ^ (cid:8).(cid:13) ; s; (cid:13) 0; s0/ (cid:27)(cid:8).(cid:14)I (cid:13) ; s; (cid:13) 0; s0/, i.e.:Final.(cid:14); s/ ^ 8s00:TDo1.(cid:13) 0; s0; s00/ (cid:27) Do1.(cid:13) ; s; s00/U (cid:27)008s:Do1.(cid:13)00; s; s00/ (cid:27) Do1.(cid:14)I (cid:13) ; s; s00/:By contradiction. Suppose that there is a model M such that M jD Final.(cid:14); s/,M jD 8s00:Do1.(cid:13) 0; s0; s00/ (cid:27) Do1.(cid:13) ; s; s00/, and M jD Do1.(cid:13) 0; s0; sc/—thus M jDDo1.(cid:13) ; s; sc/—and M jD :Do1.(cid:14)I (cid:13) ; s; sc/ for some sc. The latter means that M jD8t::Do1.(cid:14); s; t/ _ :Do1.(cid:13) ; t; sc/. Since M jD Final.(cid:14); s/ implies M jD Do1.(cid:14); s; s/by Lemma B.3, then M jD :Do1.(cid:13) ; s; sc/, contradiction.0000008s:Do1.(cid:14)(4) Implication for iteration. We have to show (cid:8).(cid:14); s; (cid:14)0; s0/ (cid:27) (cid:8).(cid:14)(cid:3); s; (cid:14)0I (cid:14)(cid:3); s0/, i.e.:00; s; s(cid:3)0I (cid:14):TDo1.(cid:14)008s/ (cid:27) Do1.(cid:14); s; s0/ (cid:27) Do1.(cid:14); s/U (cid:27)(cid:3); s; sBy contradiction. Suppose that there is a model M such that M jD 8s00:Do1.(cid:14)0; s0;s00/ (cid:27) Do1.(cid:14); s; s00/, and M jD Do1.(cid:14)0I (cid:14)(cid:3); s0; sc/ and M jD :Do1.(cid:14)(cid:3); s; sc/ forsome sc. Since M jD Do1.(cid:14)0I (cid:14)(cid:3); s0; sc/ implies M jD Do1.(cid:14)0; s0; st /—thus M jDDo1.(cid:14); s; st /—and M jD Do1.(cid:14)(cid:3); st ; sc/, and M jD Do1.(cid:14); s; st / and M jD Do1.(cid:14)(cid:3);st ; sc/ imply M jD Do1.(cid:14)(cid:3); s; sc/, contradiction.; s/:0000(5) Implication for contextualized procedure calls. We have to show that(cid:0)(cid:8)(cid:8)EnvI (cid:14)i(cid:9); s; (cid:14)00; s(cid:1)EviEtTsU(cid:27) (cid:8).TEnv V Pi .Et/U; s; (cid:14)00/:; sIt suffices to prove that:(cid:9)(cid:0)(cid:8); s; s0EnvI (cid:14)iDo1EviEtTsU(cid:1)(cid:27) Do1.TEnv V Pi .Et/U; s; s0/:G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169167We proceed by contradiction. Suppose that there exists an model M such thatg; s; s0/ and M jD :Do1.TEnvI Pi.Et/U; s; s0/, for some Et, s andM jD Do1.fEnvI (cid:14)is0. That is:EviEtTsUEviEt TsU; s; s0M jD 8P1; : : : ; Pn:M jD 9P1; : : : ; Pn: T(cid:9) ^ :Pi .EtTsU/; s; s(cid:2)(cid:9) (cid:27) Do1(cid:0)(cid:14)i(cid:1)(cid:3);/U;0VniD1(B.7); s; s0/ (cid:27) Pi .Exi; s; s0/U. Then by (B.7) therewhere (cid:9) D Texists a variable assignment such that M; (cid:27) jD (cid:9) and M; (cid:27) jD :Pi .EtTsU; s; s0/, whichEviEtTsU; s; s0/, which contradicts (B.6).implies M; (cid:27) jD :Do1.(cid:14)8Exi; s; s0:Do1.(cid:14)iEviExi(6) Implication for programs within an environment. We have to show(B.6)(cid:0)(cid:8)(cid:14)Pi .Et/TEnvVPi .Et/U; s; (cid:14)0; s0(cid:1)(cid:27) (cid:8).fEnvI (cid:14)g; s; (cid:14)0; s0/:It suffices to prove that:(cid:0)Do1(cid:14)Pi .Et/TEnvVPi .Et/U; s; s0(cid:1)(cid:27) Do1.fEnvI (cid:14)g; s; s0/:This can be done by induction on the structure of the program (cid:14) considering nil, a,(cid:30)?, and TEnv0 V P .Et/U as base cases (such programs do not make use of Env). 2Lemma B.5. For every model M of C, if there exist (cid:14)1; s1 : : : (cid:14)n; sn such that (cid:14)1 D (cid:14), s1 D s,sn D s0, M jD Final.(cid:14)n; sn/ and M jD Trans.(cid:14)i; si ; (cid:14)iC1; siC1/ for i D 1; : : : ; n (cid:0) 1, thenM jD Do1.(cid:14); s; s0/.Proof. By induction on n. If n D 1, then Final.(cid:14); s/ (cid:27) Do1.(cid:14); s; s/ by Lemma B.3. Ifn > 1, then by induction hypothesis M jD Do1.(cid:14)2; s2; s0/, hence by applying Lemma B.4,we get the thesis. 2With these lemmas in place we can finally prove the wanted result:Theorem 1. For each Golog program (cid:14):C jD 8s; s0:Do1.(cid:14); s; s0/ (cid:17) Do2.(cid:14); s; s0/:Proof. ()) by Lemmas B.2 and B.1; (() by Lemmas B.1 and B.5. 2References[1] G.R. Andrews, F.B. Schneider, Concepts and notations for concurrent programming, ACM Comput.Surveys 15 (1) (1983) 3–43.[2] M.E. Bratman, D.J. Israel, M.E. Pollack, Plans and resource-bounded practical reasoning, Comput.Intelligence 4 (1988) 349–355.[3] A.J. Bonner, M. Kifer, Concurrency and communication in transaction logic, in: Proc. Joint InternationalConference and Symposium on Logic Programming (JICSLP), Bonn, Germany, 1996, pp. 142–156.[4] J. De Bakker, E. De Vink, Control Flow Semantics, MIT Press, Cambridge, MA, 1996.[5] X.J. Chen, G. De Giacomo, Reasoning about nondeterministic and concurrent actions: A process algebraapproach, Artificial Intelligence 107 (1) (1999) 63–98.168G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169[6] G. De Giacomo, Y. Lespérance, H.J. Levesque, Reasoning about concurrent execution, prioritized interrupts,and exogenous actions in the situation calculus, in: Proc. IJCAI-97, Nagoya, Japan, 1997, pp. 1221–1226.[7] G. De Giacomo, H.J. Levesque, An incremental interpreter for high-level programs with sensing, in:Cognitive Robotics—Papers from the 1998 AAAI Fall Symposium, Orlando, FL, Technical Report FS-98-02, AAAI Press, Menlo Park, CA, 1998, pp. 28–34.[8] M. Dixon, Embedded computation and the semantics of programs, Ph.D. Thesis, Department of ComputerScience, Stanford University, Stanford, CA, 1991. Also appeared as Xerox PARC Technical Report SSL-91-1.[9] G. De Giacomo, E. Ternovskaia, R. Reiter, Nonterminating processes in the situation calculus, in: Proc.AAAI-97 Workshop on Robots, Softbots, Immobots: Theories of Action, Planning and Control, Providence,RI, 1997.[10] R.M. van Eijk, F.S. de Boer, W. van der Hoek, J.-J.Ch. Meyer, Information-passing and belief revision inmulti-agent systems, in: J.P. Müller, M.P. Singh, A.S. Rao (Eds.), Proc. ATAL-98, Paris, 1998, pp. 75–89.[11] M. Fisher, A survey of Concurrent MetateM—The language and its applications,in: D.M. Gabbay,H.J. Ohlbach (Eds.), Temporal Logic—Proc. First International Conference, Lecture Notes in ArtificialIntelligence, Vol. 827, Springer, Berlin, 1994, pp. 480–505.[12] M. Gelfond, V. Lifschitz, Representing action and change by logic programs, J. Logic Programming 17(1993) 301–327.[13] C.C. Green, Theorem proving by resolution as a basis for question-answering systems, in: MachineIntelligence, Vol. 4, Edinburgh University Press, Edinburgh, 1969, pp. 183–205.[14] V. Gupta, R. Jagadeesan, V.A. Saraswat, Computing with continuous change, Sci. Comput. Programming 30(1998) 3–50.[15] M. Hennessy, The Semantics of Programming Languages, Wiley, New York, 1990.[16] K.V. Hindriks, F.S. de Boer, W. van der Hoek, J.-J.Ch. Meyer, A formal semantics for an abstract agentprogramming language, in: M.P. Singh, A. Rao, M.J. Wooldridge (Eds.), Proc. ATAL-97, Lecture Notes inArtificial Intelligence, Vol. 1365, Springer, Berlin, 1998, pp. 215–229.[17] C.A.R. Hoare, Communicating Sequential Processes, Prentice Hall, Englewood Cliffs, NJ, 1985.[18] D. Leivant, Higher order logic, in: Handbook of Logic in Artificial Intelligence and Logic Programming,Vol. 2, Clarendon Press, Oxford, 1994, pp. 229–321.[19] Y. Lespérance, M. Jenkin, K. Tam, Reactivity in a logic-based robot programming framework, in: CognitiveRobotics—Papers from the 1998 AAAI Fall Symposium, Orlando, FL, Technical Report FS-98-02, AAAIPress, Menlo Park, CA, 1998, pp. 98–105.[20] H.J. Levesque, R. Reiter, Y. Lespérance, F. Lin, R.B. Scherl, GOLOG: A logic programming language fordynamic domains, J. Logic Programming 31 (1997) 59–84.[21] F. Lin, R. Reiter, State constraints revisited, J. Logic Comput. 4 (5) (1994) 655–678.[22] F. Lin, R. Reiter, How to progress a database, Artificial Intelligence 92 (1997) 131–167.[23] J.W. Lloyd, Foundations of Logic Programming, 2nd edn., Springer, Berlin, 1987.[24] J. McCarthy, P. Hayes, Some philosophical problems from the standpoint of artificial intelligence, in:Machine Intelligence, Vol. 4, Edinburgh University Press, Edinburgh, 1969.[25] R. Milner, Communication and Concurrency, Prentice Hall, Englewood Cliffs, NJ, 1989.[26] H.R. Nielson, F. Nielson, Semantics with Applications: A Formal Introduction, Wiley, New York, 1992.[27] G. Plotkin, A structural approach to operational semantics, Technical Report DAIMI-FN-19, ComputerScience Department, Aarhus University, Denmark, 1981.[28] D. Pym, L. Pryor, D. Murphy, Processes for plan-execution, in: Proc. 14th Workshop of the UK Planningand Scheduling Special Interest Group, 1995.[29] A.S. Rao, AgentSpeak(L): BDI agents speak out in a logical computable language, in: W. van der Velde,J.W. Perram (Eds.), Agents Breaking Away, Lecture Notes in Artificial Intelligence, Vol. 1038, Springer,Berlin, 1996, pp. 42–55.[30] A.S. Rao, M.P. Georgeff, An abstract architecture for rational agents, in: B. Nebel, C. Rich, W. Swartout(Eds.), Proc. 3rd International Conference on Principles of Knowledge Representation and Reasoning (KR-92), Cambridge, MA, Morgan Kaufmann, San Mateo, CA, 1992, pp. 439–449.[31] R. Reiter, The frame problem in the situation calculus: A simple solution (sometimes) and a completenessresult for goal regression, in: Artificial Intelligence and Mathematical Theory of Computation: Papers inHonor of John McCarthy, Academic Press, New York, 1991, pp. 359–380.G. De Giacomo et al. / Artificial Intelligence 121 (2000) 109–169169[32] R. Reiter, Proving properties of states in the situation calculus, Artificial Intelligence 64 (1993) 337–351.[33] R. Reiter, Natural actions, concurrency and continuous time in the situation calculus,in: Proc. 5thInternational Conference on Principles of Knowledge Representation and Reasoning (KR-96), Cambridge,MA, Morgan Kaufmann, San Mateo, CA, 1996, pp. 2–13.[34] R. Reiter, Knowledge in action: Logical foundation for describing and implementing dynamical systems, Inpreparation.[35] V.A. Saraswat, M. Rinard, Concurrent constraint programming, in: Proc. 17th ACM Symposium onPrinciples of Programming Languages, 1990, pp. 232–245.[36] S. Shapiro, Y. Lespérance, H.J. Levesque, Specifying communicative multiagent systems, in: W. Wobcke,M. Pagnucco, C. Zhang (Eds.), Agents and Multi-Agent Systems—Formalisms, Methodologies, andApplications, Lecture Notes in Artificial Intelligence, Vol. 1441, Springer, Berlin, 1998, pp. 1–14.[37] J.R. Shoenfield, Mathematical Logic, Addison-Wesley, Reading, MA, 1967.[38] Y. Shoham, Agent-oriented programming, Artificial Intelligence 60 (1993) 51–92.[39] C. Stirling, Modal and temporal logics for processes, in: Logics for Concurrency: Structure versus Automata,Lecture Notes in Computer Science, Vol. 1043, Springer, Berlin, 1996, pp. 149–237.[40] A. Tarski, A lattice-theoretical fixpoint theorem and its applications, Pacific J. Math. 5 (1955) 285–309.