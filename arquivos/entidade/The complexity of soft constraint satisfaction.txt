Artificial Intelligence 170 (2006) 983–1016www.elsevier.com/locate/artintThe complexity of soft constraint satisfactionDavid A. Cohen a, Martin C. Cooper b, Peter G. Jeavons c,∗,Andrei A. Krokhin da Department of Computer Science, Royal Holloway, University of London, UKb IRIT, University of Toulouse III, Francec Computing Laboratory, University of Oxford, UKd Department of Computer Science, University of Durham, UKReceived 4 October 2005; received in revised form 13 February 2006; accepted 13 April 2006Available online 5 June 2006AbstractOver the past few years there has been considerable progress in methods to systematically analyse the complexity of constraintsatisfaction problems with specified constraint types. One very powerful theoretical development in this area links the complexityof a set of constraints to a corresponding set of algebraic operations, known as polymorphisms.In this paper we extend the analysis of complexity to the more general framework of combinatorial optimisation problemsexpressed using various forms of soft constraints. We launch a systematic investigation of the complexity of these problems byextending the notion of a polymorphism to a more general algebraic operation, which we call a multimorphism. We show that manytractable sets of soft constraints, both established and novel, can be characterised by the presence of particular multimorphisms. Wealso show that a simple set of NP-hard constraints has very restricted multimorphisms. Finally, we use the notion of multimorphismto give a complete classification of complexity for the Boolean case which extends several earlier classification results for particularspecial cases.© 2006 Elsevier B.V. All rights reserved.Keywords: Soft constraints; Valued constraint satisfaction; Combinatorial optimisation; Submodular functions; Tractability; Multimorphism1. IntroductionIn the standard constraint satisfaction framework [14,38] a constraint is understood to be a predicate, or relation,specifying the allowed combinations of values for some fixed subset of variables: we will refer to such constraintshere as crisp constraints. Problems with crisp constraints deal only with feasibility: no satisfying solution is consideredbetter than any other.A number of authors have suggested that the usefulness of the constraint satisfaction framework could be greatlyenhanced by extending the definition of a constraint to include also soft constraints, which allow different measuresof desirability to be associated with different combinations of values [1,2,43]. In this extended framework a constraint* Corresponding author.E-mail addresses: d.cohen@rhul.ac.uk (D.A. Cohen), cooper@irit.fr (M.C. Cooper), peter.jeavons@comlab.ox.ac.uk (P.G. Jeavons),andrei.krokhin@durham.ac.uk (A.A. Krokhin).0004-3702/$ – see front matter © 2006 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2006.04.002984D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016can be seen as a cost function defined on a fixed subset of the variables which maps each possible combination ofvalues for those variables to a measure of desirability or undesirability.Problems with soft constraints deal with optimisation as well as feasibility: the aim is to find an assignment ofvalues to all of the variables having the best possible overall combined measure of desirability. In this paper weexamine how limiting the choice of cost functions affects the complexity of this optimisation problem.Example 1.1. Consider an optimisation problem where we have to choose sites for n service stations along a motorwayof length L, subject to the following requirements:• There are r > n possible sites at distances d1, . . . , dr along the motorway.• Each pair of consecutive service stations must be separated by a distance which is no less than A and no morethan B.• The service stations should be as equally spaced as possible.One possible way to model this situation is as follows:• Introduce variables v1, v2, . . . , vn to represent the position of each service station, where each variable must be• Impose a binary constraint on each pair vi, vi+1, i = 1, . . . , n − 1, with cost function δ, where δ(x, y) = 0 ifassigned a value from the set {d1, . . . , dr }.A (cid:2) y − x (cid:2) B and ∞ otherwise.• Impose a binary constraint on each pair vi, vi+1, i = 1, . . . , n − 1, with cost function ζ , where ζ (x, y) = |x − y|2.Add a unary constraint on v1 with cost function ζ (0, x), and a unary constraint on vn, with cost function ζ (x, L).(Note that the sum of these functions is minimal when the values of these variables are equally spaced between 0and L.)We would then seek an assignment of values from the set D = {d1, . . . , dr }, to all of the variables, which minimisesthe sum of all these cost functions:n−1(cid:2)i=1δ(vi, vi+1) + ζ (0, v1) +n−1(cid:2)i=1ζ (vi, vi+1) + ζ (vn, L).The cost of allowing additional flexibility in the specification of constraints, in order to model optimisation criteriaas well as feasibility, is generally an increase in computational difficulty. For example, we establish below that theclass of problems containing only unary constraints and a soft version of the binary equality constraint is NP-hard(see Example 2.11).On the other hand, for certain types of soft constraint it is possible to solve the associated optimisation problemsefficiently. For example, we establish below that optimisation problems of the form described in Example 1.1 can besolved in polynomial time (see Example 6.13).In the case of crisp constraints there has been considerable progress in analysing the complexity of problemsinvolving different types of constraints. This work has led to the identification of a number of classes of constraintswhich are tractable, in the sense that there exists a polynomial time algorithm to determine whether or not anycollection of constraints from such a class can be simultaneously satisfied [15,26,33,40,42]. One powerful result inthis area establishes that any tractable class of constraints over a finite domain must have relations which are allpreserved by a non-trivial algebraic operation, known as a polymorphism [6,26].In the case of soft constraints there has been little detailed investigation of the tractable cases, except for certainspecial cases on a two-valued domain [10,30], and a special case involving simple temporal constraints [31]. In anearlier paper [7] we identified a particular tractable class of binary soft constraints, and showed that this class wasmaximal, in the sense that adding any other soft binary constraint which is not in the class gives rise to a class ofproblems which is NP-hard. This class has recently been used to study the complexity of the MINIMUM COST HO-MOMORPHISM problem [21], which has been used to model the “Level of Repair Analysis” problem from operationsresearch [22] (see Example 2.7).D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016985In this paper we take the first step towards a systematic analysis of the complexity of soft constraints of arbitraryarity over arbitrary finite domains. To do this we generalise the algebraic ideas used to study crisp constraints, andintroduce a new algebraic operation which we call a multimorphism. Every cost function has an associated set ofmultimorphisms, and every multimorphism has an associated set of cost functions. We show that, for several differenttypes of multimorphism, the associated collection of soft constraints is a maximal tractable class. In other words, weshow that several maximal tractable classes of soft constraints can be precisely characterised as the collection of allsoft constraints associated with a particular multimorphism. Furthermore, we show that a simple NP-hard class of softconstraints has very restricted multimorphisms.Finally, we apply the techniques developed in the paper to the two-valued domain, where we obtain a new di-chotomy theorem which classifies the complexity of any set of soft constraints over this domain (Theorem 7.1). Thisdichotomy theorem generalises several earlier results concerning the complexity of particular Boolean constraint prob-lems, including the SATISFIABILITY problem [42], the MAX-SAT problem [9], the weighted MIN-ONES problem [10,30], and the weighted MAX-ONES problem [10,30] (see Corollary 7.12).The examples given throughout the paper demonstrate that the framework we introduce here can be used to unifyisolated results about tractable problem classes from many different application areas, as well as prompting thediscovery of new tractable classes. For example, the notion of a multimorphism generalises the notion of a poly-morphism (see Proposition 4.10), and so can be used to express earlier results concerning the characterisation oftractable subproblems of many different decision problems: in the case of the SATISFIABILITY problem these includethe HORN-SAT and 2-SAT subproblems [19]; in the case of the standard crisp constraint satisfaction problem theseinclude generalisations of HORN-SAT (such as the so-called ‘max-closed’ constraints [26,29]), generalisations of 2-SAT (such as the so-called ‘0/1/all’ or ‘implicative’ constraints [8,25,32]) and systems of linear equations [26]. Thenotion of a multimorphism can also be used to characterise tractable subproblems of optimisation problems: in thecase of the optimisation problem MAX-SAT these include the ‘0-valid’, ‘1-valid’ and ‘2-monotone’ constraints [10];in the case of optimisation problems over sets these include the minimisation of submodular set functions [23,39] andbisubmodular set functions [18].2. DefinitionsSeveral alternative mathematical frameworks for soft constraints have been proposed in the literature, includingthe very general frameworks of ‘semi-ring based constraints’ and ‘valued constraints’ [1,2,43]. For simplicity, weshall adopt the valued constraint framework here (the relationship with the semi-ring framework is discussed brieflyin Section 8).In the valued constraint framework each constraint has an associated function which assigns a cost to each possibleassignment of values. These costs are chosen from some valuation structure, satisfying the following definition.Definition 2.1. A valuation structure, Ω, is a totally ordered set, with a minimum and a maximum element (denoted 0and ∞), together with a commutative, associative binary aggregation operator (denoted ⊕), such that for all α, β, γ ∈Ω, α ⊕ 0 = α and α ⊕ γ (cid:3) β ⊕ γ whenever α (cid:3) β.Definition 2.2. An instance of the valued constraint satisfaction problem, VCSP, is a tuple P = (cid:6)V , D, C, Ω(cid:7)where:• V is a finite set of variables;• D is a finite set of possible values;• Ω is a valuation structure representing possible costs;• C is a set of constraints.Each element of C is a pair c = (cid:6)σ, φ(cid:7) where σ is a tuple of variables called the scope of c, and φ is a mappingfrom D|σ | to Ω, called the cost function of c.986D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016Definition 2.3. For any VCSP instance P = (cid:6)V , D, C, Ω(cid:7), an assignment for P is a mapping s : V → D. The costof an assignment s, denoted CostP (s), is given by the aggregation of the costs for the restrictions of s onto eachconstraint scope, that is,CostP (s) def=(cid:5).s(v1), s(v2), . . . , s(vm)(cid:3)φ(cid:4)(cid:6)(cid:6)v1,v2,...,vm(cid:7),φ(cid:7)∈CA solution to P is an assignment with minimal cost, and the question is to find a solution.Our results in Sections 3 and 4 will apply to any valuation structure satisfying Definition 2.1. In Sections 5, 6 and 7,and in the examples of particular soft constraint problems given throughout the paper, we will focus on the valuationstructure R+, consisting of the non-negative real numbers together with infinity, with the usual ordering and the usualaddition operation. (Possible extensions of our results to other valuation structures are discussed briefly in Section 8.)The valuation structure R+ is sufficiently flexible to allow us to express a wide range of problems as valuedconstraint satisfaction problems with costs in R+, as the following examples indicate.Example 2.4 (Standard CSP). In the standard constraint satisfaction problem with crisp constraints [14,36] eachconstraint c is specified by a pair, (cid:6)σ, R(cid:7), where σ is the scope of c and R is a relation specifying the allowedcombinations of values for the variables in σ .For any standard constraint satisfaction problem instance P, we can define a corresponding valued constraintsatisfaction problem instance (cid:6)P in which the range of the cost functions of all the constraints is the set {0, ∞} ⊆ R+.For each crisp constraint (cid:6)σ, R(cid:7) of P, we define a corresponding valued constraint (cid:6)σ, φR(cid:7) of (cid:6)P; the cost functionφR maps each tuple allowed by R to 0, and each tuple disallowed by R to ∞. The cost of an assignment s for (cid:6)Pis computed as in Definition 2.3, so it equals the minimal possible cost, 0, if and only if s satisfies all of the crispconstraints in P.Example 2.5 (Max-CSP). For any standard constraint satisfaction problem instance P with crisp constraints, we candefine a corresponding valued constraint satisfaction problem instance P # in which the range of the cost functionsof all the constraints is the set {0, 1} ⊆ R+. For each crisp constraint (cid:6)σ, R(cid:7) of P, we define a corresponding valuedconstraint (cid:6)σ, χR(cid:7) of P #; the cost function χR maps each tuple allowed by R to 0, and each tuple disallowed by Rto 1.The cost of an assignment s for P # is again computed as in Definition 2.3, so in this case it equals the totalnumber of crisp constraints in P which are violated by s. Hence a solution to P # corresponds to an assignment whichviolates the minimal number of constraints of P, and hence satisfies the maximal number of constraints of P. Findingassignments of this kind is generally referred to as solving the MAX-CSP problem [17,34].Example 2.6 (Minimum k-Terminal Cut and Min-Cut). Let G be an undirected graph with vertices V and edgesE, and let {v1, v2, . . . , vk} ⊆ V be a set of k distinguished vertices. The problem of finding a smallest set of edgeswhose removal disconnects the distinguished vertices from each other is known as the MINIMUM k-TERMINAL CUTproblem [12]; such a set of edges is called a minimum k-terminal cut. (In the special case when k = 2 this problem isknown as the MIN-CUT problem [39].)Each instance of the MINIMUM k-TERMINAL CUT problem can be formulated as a VCSP instance PG with costsin R+. The instance PG is constructed as follows: the variables of PG are the vertices V of G, and they take values inthe set D = {1, 2, . . . , k}. For each distinguished vertex vi ∈ {v1, v2, . . . , vk}, impose a unary constraint on the variablevi with cost function ψi : {0, 1} → R+, defined as follows:(cid:7)ψi(x) =if x = i,0∞ otherwise.For each edge e ∈ E, impose a binary constraint with scope e and cost function φEQ : D2 → R+, defined as followsφEQ(x, y) =(cid:7)01if x = y,otherwise.It is straightforward to check that the number of edges in a minimum k-terminal cut of G is equal to the cost of asolution to PG.D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016987Example 2.7 (Level of Repair Analysis). Level of Repair Analysis (LORA) is a prescribed procedure for defencelogistics support planning [22]. For a complex engineering system containing perhaps thousands of assemblies, sub-assemblies, modules and components, LORA seeks to determine an optimal provision of repair and maintenancefacilities to minimise overall life-cycle costs.In the simple model of this problem presented in [22] the engineering system is modelled as a set of items V ,together with a binary relation E on V such that E(v, v(cid:10)) holds when item v is contained in item v(cid:10). Each item inV must be assigned a repair level (such as “central repair”, “local repair”, “discard”) chosen from some fixed set ofpossible repair levels, D. There is a fixed cost cdv associated with the assignment of repair level d ∈ D to item v ∈ V(which may be infinite if that repair level is not available for that item). There are also some restrictions on the allowedassignments for pairs of items related by E: for example, if an item is assigned “discard”, then all items contained inthat item must also be assigned this repair level. The question is to find an assignment of repair levels to items whichminimises the total cost.For any LORA instance of this kind, we can define a corresponding valued constraint satisfaction problem instanceP with costs in R+. For each item v ∈ V we define a unary constraint (cid:6)(cid:6)v(cid:7), κv(cid:7) of P, where the cost function κv mapseach element d ∈ D to cdv. For each pair (cid:6)v, v(cid:10)(cid:7) of items related by E, we define a valued constraint (cid:6)(cid:6)v, v(cid:10)(cid:7), φ(cid:7) of P,where the cost function φ maps each pair of allowed repair levels to 0, and each pair of disallowed repair levels to ∞.A solution to P corresponds to an assignment of repair levels which minimises the total cost.The problem of finding a solution to a valued constraint satisfaction problem is an NP-optimisation problem, thatis, it lies in the complexity class NPO (see [10] for a formal definition of this class).For each valued constraint satisfaction problem there is a corresponding decision problem in which the question isto decide whether there is a solution with cost lower than some given threshold value. It is clear from Example 2.4that there is a polynomial-time reduction to this decision problem from the standard constraint satisfaction problem,which is known to be NP-complete [36], so the general VCSP is NP-hard. In this paper we will consider the effect ofrestricting the forms of cost function allowed in the constraints; we will show that in some cases this results in moretractable versions of the VCSP.Definition 2.8. Let D be a set and Ω a valuation structure. A valued constraint language over D with costs in Ω isdefined to be a set, Γ , such that each φ ∈ Γ is a function from Dm to Ω, for some m ∈ N, where m is called the arityof φ. The class VCSP(Γ ) is defined to be the class of all VCSP instances where the cost functions of all constraintslie in Γ .We will say that a finite valued constraint language Γ is tractable if every instance in VCSP(Γ ) can be solvedin polynomial time. We will say that an infinite valued constraint language is tractable if every finite subset1 of it istractable. Finally, we will say that a valued constraint language Γ is NP-hard if the decision problem correspondingto VCSP(Γ (cid:10)) is NP-complete, for some finite Γ (cid:10) ⊆ Γ .Example 2.9 (SAT and Max-SAT). Let Γ be any valued constraint language over a set D, where |D| = 2. In this caseVCSP(Γ ) is called a Boolean valued constraint satisfaction problem.If we restrict Γ even further, by only allowing cost functions with range {0, ∞} ⊆ R+, as in Example 2.4, then eachVCSP(Γ ) corresponds precisely to a standard Boolean constraint satisfaction problem with crisp constraints. Suchproblems are sometimes known as GENERALISED SATISFIABILITY problems [19,42]. The complexity of VCSP(Γ )for such restricted sets Γ has been completely characterised, and the six tractable cases have been identified [10,19,42].Alternatively, if we restrict Γ by only allowing functions with range {0, 1} ⊆ R+, as in Example 2.5, then eachVCSP(Γ ) corresponds precisely to a standard Boolean maximum satisfiability problem, in which the aim is to satisfythe maximum number of crisp constraints. Such problems are sometimes known as MAX-SAT problems [10]. Thecomplexity of VCSP(Γ ) for such restricted sets Γ has been completely characterised, and the three tractable caseshave been identified (see Theorem 7.6 of [10]).1 Defining tractability in terms of finite subsets ensures that the tractability of a valued constraint language is independent of whether the costfunctions are represented explicitly (via tables of values) or implicitly (via oracles).988D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016The next two examples indicate that generalising the constraint satisfaction framework to include valued constraintscan indeed increase the computational complexity. For example, the standard 2-SATISFIABILITY problem is well-known to be tractable [19], but the valued constraint satisfaction problem involving only the single binary Booleanfunction, φXOR, defined in Example 2.10, is NP-hard.Example 2.10. Let ΓXOR be the Boolean valued constraint language over D = {0, 1} which contains just the singlebinary function φXOR : D2 → R+ defined by(cid:7)φXOR(x, y) =0 if x (cid:11)= y,1 otherwise.The problem VCSP(ΓXOR) corresponds to the MAX-SAT problem for the exclusive-or predicate, which is known tobe NP-hard (see Lemma 7.4 of [10]), so ΓXOR is NP-hard.Similarly, the standard constraint satisfaction problem involving only crisp unary constraints and equality con-straints is clearly trivial, but the valued constraint satisfaction problem involving only unary valued constraints and asoft version of the equality constraint, specified by the function φEQ defined in Example 2.6, is NP-hard.Example 2.11. Let Γ3 be the valued constraint language over D = {0, 1, 2} consisting of the set of all unary functionswith costs in R+ together with the single binary function φEQ : D2 → R+, defined in Example 2.6.Even though Γ3 is apparently simple, it can be shown that VCSP(Γ3) is NP-hard, by reduction from the MINIMUM3-TERMINAL CUT problem defined in Example 2.6, which is known to be NP-hard [12]. To obtain the reduction,we use the construction described in Example 2.6 to transform each instance of MINIMUM 3-TERMINAL CUT to aninstance of VCSP(Γ3) in polynomial time.In order to allow us to translate easily between relations and functions, as described in Example 2.4, we make thefollowing definitions.Definition 2.12. Any function φ which only takes values in the set {0, ∞} ⊆ Ω will be called a crisp function.For any relation R, with arity m, we define an associated crisp function known as the feasibility function of R, anddenoted φR, as follows:φR(x1, x2, . . . , xm) =(cid:7)if (cid:6)x1, x2, . . . , xm(cid:7) ∈ R,0∞ otherwise.For any m-ary function φ into any valuation structure Ω, we define a relation known as the feasibility relation of φ,and denoted Feas(φ), as follows:(cid:6)x1, x2, . . . , xm(cid:7) ∈ Feas(φ) ⇔ φ(x1, x2, . . . , xm) < ∞.A function φ will be called essentially crisp if φ takes at most one finite value, that is, there is some value α suchthat φ(x) = β < ∞ ⇒ β = α. Any valued constraint language Γ containing essentially crisp functions only will becalled an essentially crisp language.Note that when Γ is an essentially crisp language any assignment with finite cost has the same cost as any otherassignment with finite cost. Hence we can solve any instance of VCSP(Γ ) for such languages by solving the cor-responding standard constraint satisfaction problem in which each valued constraint (cid:6)σ, φ(cid:7) is replaced by the crispconstraint (cid:6)σ, Feas(φ)(cid:7) (see Definition 2.12). We will use this observation a number of times in establishing the re-sults below.3. ExpressibilityLet Γ be a valued constraint language, and consider an arbitrary instance P in VCSP(Γ ). The variables in the scopeof any constraint of P are explicitly constrained. What is more, any subset of the variables of P may be constrainedimplicitly, due to the combined effect of the constraints of P. The cost function which describes this implicit constraintmay or may not be an element of Γ , but can, in a sense, be expressed using elements of Γ .The next two definitions formalise this idea of a function being expressible over a valued constraint language.D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016989Definition 3.1. For any VCSP instance P = (cid:6)V , D, C, Ω(cid:7), and any tuple of distinct variables W = (cid:6)v1, . . . , vk(cid:7), thecost function of P on W , denoted ΦWP , is defined as follows:ΦWP (d1, . . . , dk) def=min{s : V →D|(cid:6)s(v1),...,s(vk)(cid:7)=(cid:6)d1,...,dk(cid:7)}CostP (s).Note that the cost function of P on W is a kind of projection of the overall cost function onto a specified subset ofthe variables.Definition 3.2. A function φ is expressible over a valued constraint language Γ if there exists an instance P =(cid:6)V , D, C, Ω(cid:7) in VCSP(Γ ) and a list W of variables from V such that φ = ΦWP .The set of all functions expressible over Γ will be denoted Γ ∗.In all cases Γ ∗ ⊇ Γ , but it is often the case that Γ ∗ contains many more functions than Γ , as the next exampleillustrates.Example 3.3. Let D = {0, 1, 2, . . . , |D| − 1} be a subset of the integers, and let Γ1 = { φ0, φ1} be the valued constraintlanguage over D consisting of the constant unary cost function φ0 : D → R+ defined by φ0(x) = 1 and the unary costfunction φ1 : D → R+ defined by φ1(x) = x.In this case the language (Γ1)∗ also contains all cost functions defined by linear expressions with non-negativeinteger coefficients, since for any such cost function φ we haveφ(x1, x2, . . . , xm) = a0φ0(x1) +m(cid:2)i=1aiφ1(xi)for some set of non-negative integers a0, a1, . . . , am, and hence φ = ΦThis much larger valued constraint language will be denoted ΓLIN.(cid:6)x1,...,xm(cid:7)Pfor some instance P of VCSP(Γ1).The notion of expressibility is a key tool in analysing the complexity of valued constraint languages, as the nextresult shows.Theorem 3.4. Let Γ and Γ (cid:10) be valued constraint languages with Γ (cid:10) ⊆ Γ ∗.• If Γ is tractable, then Γ (cid:10) is also tractable.• If Γ (cid:10) is NP-hard, then Γ is also NP-hard.Proof. Let Γ0 be a finite subset of Γ (cid:10), let P = (cid:6)V , D, C, Ω(cid:7) be any instance in VCSP(Γ0), and let c = (cid:6)σ, φ(cid:7) be aconstraint in C.Since Γ (cid:10) ⊆ Γ ∗ we know that φ is expressible over Γ , so there exists an instance Pφ in VCSP(Γ ), and a list ofvariables W of Pφ, such that ΦW= φ. Hence we can replace the constraint c in P with a copy of Pφ (where thePφvariables in the scope σ are identified with the list of variables W , and the remaining variables of Pφ are disjoint fromV ) to obtain a new problem instance P (cid:10). Note that the solutions to P (cid:10), when restricted to V , correspond precisely tothe original solutions to P and have the same costs.By repeating this construction for each constraint c of P, we can obtain an instance P (cid:10)(cid:10) of VCSP(Γ ) whosesolutions, when restricted to V , correspond precisely to the original solutions to P and have the same costs. Since Γ0is finite, there is a bound on the size of the instances Pφ used in the construction, and so the size of P (cid:10)(cid:10) is bounded bya constant multiple of the size of P.If Γ is tractable, then we can solve P in polynomial time by carrying out this construction, using a polynomialtime algorithm for VCSP(Γ ), and then restricting the solutions obtained to the original variables V . This is sufficientto establish that Γ (cid:10) is tractable.If Γ (cid:10) is NP-hard, then this construction establishes that Γ is also NP-hard. (cid:2)Example 3.5. Consider the languages Γ1 and ΓLIN defined in Example 3.3. Since Γ1 contains only unary cost func-tions it is clearly tractable. Since ΓLIN ⊆ (Γ1)∗, it follows from Theorem 3.4 that ΓLIN is tractable.990D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10164. MultimorphismsFor crisp constraints, it has been shown that the expressive power of a set of relations is determined by certainalgebraic invariance properties of those relations, known as polymorphisms [6,26–28,41,46].Throughout the rest of this paper, the ith component of a tuple t will be denoted t[i].Definition 4.1. A polymorphism of a relation R ⊆ Dm is a function f : Dk → D, for some k, such that whenevert1, . . . , tk are elements of R then so is (cid:6)f (t1[1], . . . , tk[1]), . . . , f (t1[m], . . . , tk[m])(cid:7).Example 4.2. Let D = {0, 1, 2, . . . , |D|−1} be a subset of the integers, and let R be the ternary relation over D definedby R = {(cid:6)x, y, z(cid:7) | ax + by (cid:2) cz}, where a, b, c are positive constants. Consider the function f : D2 → D defined byf (x, y) = Min(x, y). For any elements, t1, t2, of R we have that at1[1] + bt1[2] (cid:2) ct1[3] and at2[1] + bt2[2] (cid:2) ct2[3],which together imply that(cid:5)(cid:4)t1[1], t2[1](cid:5)(cid:4)t1[3], t2[3].(cid:5)(cid:4)t1[2], t2[2]+ b Min(cid:2) c Mina MinHence f is a polymorphism of R, and we will say that R has the polymorphism Min.The concept of a polymorphism is specific to relations, and cannot be applied directly to the functions of a valuedconstraint language. However, we now introduce a more general notion, which we call a multimorphism, which doesapply directly to functions (see Fig. 1 for a concrete example).Definition 4.3. Let D be a set, Ω a valuation structure, and φ : Dm → Ω a function.We say that F : Dk → Dk is a multimorphism of φ if, for any list of k-tuples t1, t2, . . . , tm over D we have(cid:5)(cid:4)t1[i], t2[i], . . . , tm[i](cid:5)(cid:4)F (t1)[i], F (t2)[i], . . . , F (tm)[i]k(cid:3)k(cid:3)(cid:2)φφ.(1)i=1i=1If F is a multimorphism of every function in a language Γ , then we will say that F is a multimorphism of Γ , and thatΓ has the multimorphism F . The largest such language, consisting of all functions φ with costs in Ω which have Fas a multimorphism, will be denoted ImpΩ (F ).The notation ImpΩ (F ) is an abbreviation for “Improved by F ”; this term was chosen because the functions forwhich F is a multimorphism are precisely those functions whose aggregated value is “improved” (i.e., lowered, orleft unchanged) by applying the function F (coordinatewise) to any suitable collection of argument vectors, to obtaina new collection of argument vectors (Eq. (1)).Fig. 1. An example of the form of inequality that shows that the function φ : {0, 1}3 → R+ defined by φ(x, y, z) = 3x + 2y + z has the multimor-phism F = (cid:6)Min, Max(cid:7). (See Example 4.4.)D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016991It will often be convenient to describe a multimorphism F : Dk → Dk by listing its k separate component functions,Fi : Dk → D, defined by Fi(x1, . . . , xk) = F (x1, . . . , xk)[i].Example 4.4. Let D = {0, 1, 2, . . . , |D| − 1} be a subset of the integers, and let φ : D3 → R+ be the linear functiondefined by φ(x, y, z) = ax + by + cz, where a, b, c are positive constants.Consider the function F : D2 → D2 defined by F (x, y) = (cid:6)Min(x, y), Max(x, y)(cid:7).For any list of pairs, t1, t2, t3, over D we have:(cid:5)(cid:4)F (t1)[i], F (t2)[i], F (t3)[i]φ2(cid:3)i=1(cid:5)t3[1], t3[2], Max(cid:4)t3[1], t3[2](cid:5)(cid:9)(cid:5)[i]== φ⊕ φ= a Min2(cid:3)(cid:8)φ(cid:5)(cid:9)(cid:4)(cid:8)(cid:5)(cid:5)(cid:4)Min[i], . . . ,(cid:4)t3[1], t3[2](cid:5)(cid:4)t1[1], t1[2], MaxMin(cid:5)(cid:4)t1[1], t1[2]i=1(cid:4)(cid:4), MinMin(cid:5)(cid:4)(cid:4)t1[1], t1[2]Max(cid:5)(cid:4)t1[1], t1[2](cid:4)t1[1], t1[2](cid:5)t2[1], t2[2], Min(cid:5)(cid:4)(cid:4)t3[1], t3[2]t2[1], t2[2], Max, Max(cid:5)(cid:4)(cid:5)(cid:4)t3[1], t3[2]+ c Mint2[1], t2[2]+ b Min(cid:5)(cid:5)(cid:4)(cid:4)t1[1], t1[2]t2[1], t2[2]+ b Max+ a Max(cid:5)(cid:4)(cid:5)(cid:4)+ ct2[1] + t2[2]+ bt1[1] + t1[2](cid:5)(cid:4)t1[i], t2[i], t3[i](cid:5)(cid:4)t3[1], t3[2]+ c Max(cid:5)(cid:4)t3[1] + t3[2]2(cid:3)(cid:5)(cid:5)φ.= a=i=1(A particular concrete example is illustrated in Fig. 1.)Hence F is a multimorphism of φ, and we will say that φ has the multimorphism (cid:6)Min, Max(cid:7).The next result establishes that multimorphisms have the key property that they extend to all functions expressibleover a given language.Theorem 4.5. If F is a multimorphism of a valued constraint language Γ , then F is also a multimorphism of Γ ∗.Proof. Let F be a multimorphism of Γ , and let φ1, φ2 be arbitrary elements of Γ . By Definition 4.3, F is a multi-morphism of φ1 ⊕ φ2. Similarly, since Eq. (1) holds for all choices of tuples t, F is a multimorphism of the functionobtained by minimising φ1 over any subset of its arguments. Hence, by Definition 3.2, F is a multimorphism of anyfunction in Γ ∗. (cid:2)We now show that some important classes of functions are characterised by the property of having a particularform of multimorphism.Example 4.6. For any finite set V , a real-valued function ψ defined on subsets of V is called a submodular func-tion [39] if, for all subsets S and T of V ,ψ(S ∩ T ) + ψ(S ∪ T ) (cid:2) ψ(S) + ψ(T ).(2)The problem of SUBMODULAR FUNCTION MINIMISATION consists in finding a subset S of V for which the value ofψ(S) is minimal. Such problems arise in a number of different contexts [39]. For example, Cunningham [11] showedthat finding the maximum flow in a network can be viewed as a special case of the general problem of submodularfunction minimisation.It has been known for a long time that submodular functions can be minimised in polynomial time using theellipsoid method [20]. Recently, several different strongly polynomial, combinatorial algorithms have been proposedfor this problem [16,23,44].Any function ψ defined on subsets of a set V = {v1, . . . , vn} can be associated with a function φ : {0, 1}n → R+defined as follows: for each tuple t ∈ D|V |, set φ(t) = ψ(T ), where T = {vi | t[i] = 1}.992D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016For any tuples s, t over {0, 1}, if we set S = {vi | s[i] = 1} and T = {vi | t[i] = 1}, then S ∩ T = {vi |Min(s[i], t[i]) = 1}, where Min is the function returning the minimum of its two arguments. Similarly, S ∪ T ={vi | Max(s[i], t[i]) = 1}, where Max is the function returning the maximum of its two arguments. Hence, comparingEq. (2) and Eq. (1) (Definition 4.3), it follows that ψ is submodular if and only if the corresponding cost function φhas the multimorphism (cid:6)Min, Max(cid:7).Example 4.7. For any finite set V , a real-valued function ψ defined on pairs of disjoint subsets of V is called abisubmodular function [18] if for all pairs (cid:6)S1, S2(cid:7) and (cid:6)T1, T2(cid:7) of disjoint subsets of V ,(cid:5)(cid:4)(cid:6)S1, S2(cid:7) (cid:18) (cid:6)T1, T2(cid:7)(cid:5)(cid:4)(cid:6)S1, S2(cid:7) (cid:17) (cid:6)T1, T2(cid:7)(cid:5)(cid:4)(cid:6)T1, T2(cid:7)(cid:5)(cid:4)(cid:6)S1, S2(cid:7)(cid:2) ψ+ ψ+ ψ(3)ψwhere(cid:6)S1, S2(cid:7) (cid:17) (cid:6)T1, T2(cid:7) = (cid:6)S1 ∩ T1, S2 ∩ T2(cid:7),(cid:8)(cid:6)S1, S2(cid:7) (cid:18) (cid:6)T1, T2(cid:7) =(S1 ∪ T1) \ (S2 ∪ T2), (S2 ∪ T2) \ (S1 ∪ T1)(cid:9).It is known [18] that a bisubmodular function ψ which takes integer values only can be minimised in O(|V |5 log M)time, where M designates the maximum value of the function ψ.Any function ψ defined on pairs of disjoint subsets of a set V = {v1, . . . , vn} can be associated with a functionφ : {0, 1, 2}n → R+ defined as follows: for each tuple t ∈ D|V |, set φ(t) = ψ((cid:6)T1, T2(cid:7)), where T1 = {vi | t[i] = 1} andT2 = {vi | t[i] = 2}.Arguing as in Example 4.6, if follows from Eq. (3) that ψ is bisubmodular if and only if the corresponding costfunction φ has the multimorphism (cid:6)min0(x, y), max0(x, y)(cid:7), where(cid:10)min0(x, y) =max0(x, y) =(cid:7)Min(x, y)0Max(x, y)0if {x, y} (cid:11)= {1, 2},otherwise,if {x, y} (cid:11)= {1, 2},otherwise.In Section 6 we will show that a wide range of tractable optimisation problems with costs in R+ are characterisedby the presence of certain forms of multimorphism. In Section 7 we will show that in the Boolean case every suchtractable optimisation problem of the form VCSP(Γ ) is characterised by the presence of a particular multimorphism.A function F : k → Dk is called conservative if, for each possible choice of x1, x2, . . . , xk, the tuple F (x1, x2, . . . ,xk) contains the same multi-set of values x1, x2, . . . , xk (in some order).Example 4.8. For any totally ordered set D, the function F : Dk → Dk which returns its arguments in sorted order isconservative. For example, the function F : D2 → D2 defined by F (x, y) = (cid:6)Min(x, y), Max(x, y)(cid:7) is conservative.On the other hand, the function F : D2 → D2 defined by F (x, y) = (cid:6)Max(x, y), Max(x, y)(cid:7) is not conservative.Lemma 4.9. Any conservative function F : Dk → Dk is a multimorphism of all unary cost functions.Proof. If F is conservative, then Eq. (1) of Definition 4.3 holds (with equality) for any unary function φ, so F is amultimorphism of any unary function. (cid:2)There is a close relationship between the polymorphisms of a relation R and the multimorphisms of the correspond-ing feasibility function φR, as the next result makes clear.Proposition 4.10. Let R be a relation of arity m, and let φR be the corresponding feasibility function with range{0, ∞} defined in Definition 2.12.For any collection of polymorphisms f1, f2, . . . , fk : Dk → D of R, the function F : Dk → Dk is a multimorphismof φR, whereF (x1, x2, . . . , xk) =(cid:8)(cid:9)f1(x1, x2, . . . , xk), f2(x1, x2, . . . , xk), . . . , fk(x1, x2, . . . , xk).Furthermore, if F : Dk → Dk is a multimorphism of a function φ : Dm → R+, then each of the k componentfunctions of F is a polymorphism of the relation Feas(φ).D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016993Proof. Follows immediately from Definitions 4.1 and 4.3 restricted to the special case of crisp functions. (cid:2)Proposition 4.10 shows that, in the special case of crisp cost functions, a multimorphism can be seen as simply acollection of polymorphisms (which need not be distinct), and a polymorphism can be seen as simply a componentfunction of a multimorphism. Hence the notion of a multimorphism can be viewed as an extension and generalisationof the notion of a polymorphism.5. A family of NP-hard languagesIn the remainder of the paper we will use the results obtained above to classify the complexity of a wide range ofvalued constraint languages with costs in R+. We start by establishing a sufficient condition for such a language to beNP-hard.Proposition 5.1. Let Γ be a valued constraint language over a set D, with costs in R+. If there exist d, d (cid:10) ∈ D, andα, β ∈ R+, with α < β < ∞, such that the binary function φgiven byXORβαφXORβα(x, y) =(cid:11)if x (cid:11)= y ∧ x, y ∈ {d, d (cid:10)},if x = y ∧ x, y ∈ {d, d (cid:10)},αβ∞ otherwiseis expressible over Γ , then VCSP(Γ ) is NP-hard.}) has finite cost if and only if it assigns one of the two valuesProof. An assignment to an instance of VCSP({φd and d (cid:10) to all (constrained) variables. Hence we may restrict all variables to these two values. Lemma 7.4 of [10]states that the two-valued problem VCSP({φXOR}) is NP-hard, where φXOR is the Boolean exclusive-or function, asdefined in Example 2.10. Since adding a constant to all cost functions, and scaling all costs by a constant factor, does})not affect the difficulty of solving a VCSP instance over the valuation structure R+, we conclude that VCSP({φis also NP-hard. Hence, by Theorem 3.4, VCSP(Γ ) is NP-hard. (cid:2)XORβαXORβαNext we show that the set of multimorphisms of any Boolean language which is shown to be NP-hard usingProposition 5.1 must be very restricted.Definition 5.2. A function f : Dk → D is called essentially unary if there exists a non-constant unary functiong : D → D and an index i ∈ {1, 2, . . . , k} such that f (d1, d2, . . . , dk) = g(di) for all choices of d1, d2, . . . , dk.Definition 5.3. An injective multimorphism in which every component function is essentially unary will be calledtrivial.Theorem 5.4. A function F : {0, 1}k → {0, 1}k is a multimorphism of the valued Boolean constraint language ΓXORdefined in Example 2.10 if and only if F is trivial.Proof. It is straightforward to check that any injective function F : {0, 1}2 → {0, 1}2 where each component functionis essentially unary is a multimorphism of ΓXOR = {φXOR}.To establish the converse, let D = {0, 1} and let F : Dk → Dk be any multimorphism of φXOR. By Definition 4.3we have∀s, t ∈ Dk,k(cid:2)i=1(cid:4)(cid:5)F (s)[i], F (t)[i](cid:2)φXOR(cid:5)(cid:4)s[i], t[i].φXORk(cid:2)i=1For any pair of tuples s and t, we define the Hamming distance between s and t, denoted H (s, t), to be the number ofcoordinate positions at which they differ. We can rewrite the above inequality using Hamming distances to obtain∀s, t ∈ Dk,k − H(cid:5)(cid:4)F (s), F (t)(cid:2) k − H (s, t),994and so∀s, t ∈ Dk, HD.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016(cid:5)(cid:4)F (s), F (t)(cid:3) H (s, t).(4)This implies that F is injective, and hence a bijection from Dk to Dk, so by summing over all elements of Dk weobtain(cid:2)Hs,t∈Dk(cid:5)(cid:4)F (s), F (t)=(cid:2)H (s, t).s,t∈DkFrom Eqs. (4) and (5) it follows that(cid:5)(cid:4)F (s), F (t)∀s, t ∈ Dk, H= H (s, t)Now let 0 be the all zero k-tuple and define the function PF : Dk → Dk by setting(cid:10)PF (s)[i] =1 − s[i]s[i]if F (0)[i] = 1,otherwise.(5)(6)Since φXOR(a, b) = φXOR(1 − a, 1 − b), we have that(cid:4)PF(cid:5)(cid:4)F (s)[i], PF(cid:5)(cid:4)F (t)(cid:5)[i]=φXORk(cid:2)i=1(cid:5)(cid:4)F (s)[i], F (t)[i],φXORk(cid:2)i=1so F ◦ PF is a multimorphism of φXOR. By construction, PF (F (0)) = 0, and it follows from Eq. (6) (by setting t = 0)that F ◦ PF is conservative.Let ti be the k-tuple which is zero except at position i. We can re-order the components of the conservative functionF ◦ PF to obtain the function F (cid:10) which fixes each ti . Now consider a k-tuple s. The function F (cid:10) is conservative, andby Eq. (6) we have that H (F (cid:10)(s), ti) = H (s, ti), for each ti . It follows that F (cid:10)(s) has ones exactly where s does, andso F (cid:10) is the identity function. Hence F ◦ PF simply returns its list of arguments in some fixed order.Finally, since F = (F ◦ PF ) ◦ PF , it follows that each component function of F is essentially unary. (cid:2)Corollary 5.5. Let Γ be a valued constraint language over {0, 1}, with costs in R+.defined in Proposition 5.1 is expressible in Γ for some α, β ∈ R+, with α < β < ∞,If the cost function φXORβαthen every multimorphism of Γ is trivial.Proof. Follows immediately from Theorems 5.4, 4.5, and the fact that the set of multimorphisms of any cost functionwith costs in R+ is unchanged by adding a constant and scaling all values by a constant factor. (cid:2)6. Multimorphisms and tractable languagesIn this section we will present several maximal tractable valued constraint languages with costs in R+. Someof these are translations of known tractable optimisation problems into the VCSP framework, and others are noveltractable classes. In all cases we are able to give a characterisation of the tractable language in terms of a singlemultimorphism. Hence, in all cases we show that the presence of a certain kind of multimorphism is sufficient toguarantee tractability.We first make the following observations:• If Γ is a tractable valued constraint language with costs in R+, then the set of relations {Feas(φ) | φ ∈ Γ } mustbe a tractable crisp constraint language. By the results of [6,26,28], this implies that each relation Feas(φ) musthave some fixed set of polymorphisms which guarantees the tractability of this set of relations.• By Proposition 4.10, we know that if F : Dk → Dk is a multimorphism of a function φ, then each of the kcomponent functions of F is a polymorphism of the relation Feas(φ).Hence, in our search for tractable valued constraint languages with costs in R+ a sensible place to start is by consid-ering those multimorphisms whose component functions are polymorphisms which guarantee tractability. The mostD.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016995straightforward examples of such polymorphisms are constant functions, maximum and minimum functions on or-dered sets, majority functions and minority functions [26]; the examples we give in this section are all obtained bycombining these simple functions in various ways.We will show in Section 7 that the examples considered in this section are sufficient to obtain a complete charac-terisation of the complexity of all valued Boolean constraint languages with costs in R+.6.1. Constant multimorphismsThe first example we consider is a rather straightforward family of tractable languages, characterised by the pres-ence of a single unary multimorphism with a constant value.Lemma 6.1. A cost function φ has a unary multimorphism with constant value d if and only if the value ofφ(d, d, . . . , d) is the smallest value in the range of φ.Example 6.2. A constant cost function has all possible constant unary multimorphisms.Example 6.3. The valued constraint language ΓLIN defined in Example 3.3 has the constant unary multimorphismwith value 0.Although the proof of tractability for this case is trivial, the proof that every language characterised by a constantmultimorphism is a maximal tractable language is more interesting, and provides a simple example of the techniqueswe shall use for other cases.Theorem 6.4. Let D be a set, and let F : D → D be a constant function.1. The set of functions ImpR+(F ) is a tractable valued constraint language.2. Any valued constraint language Γ such that Γ ⊃ ImpR+ (F ) is NP-hard.Proof. Let dF be the (constant) value of F .1. Let φ be any function in ImpR+ (F ), and let m be the arity of φ. Since F is a multimorphism of φ, we have that,for all d1, d2, . . . , dm ∈ D,φ(dF , dF , . . . , dF ) (cid:2) φ(d1, d2, . . . , dm).Hence any instance P in VCSP(ImpR+ (F )) has a solution which assigns the value dF to every variable, soVCSP(ImpR+ (F )) is tractable.2. Now assume that Γ ⊃ ImpR+(F ), and hence Γ contains a function φ of some arity m such that F is not amultimorphism of φ. Hence there exist d1, d2, . . . , dm ∈ D such that φ(dF , dF , . . . , dF ) > φ(d1, d2, . . . , dm).If φ(dF , . . . , dF ) < ∞, then set μ = (φ(dF , . . . , dF ) − φ(d1, . . . , dm))/2, otherwise set μ = 1. Choose some i0such that di0(cid:11)= dF . Now define the functions δ and ψ as follows:(cid:10)if (cid:6)x1, . . . , xm(cid:7) ∈ {(cid:6)d1, . . . , dm(cid:7), (cid:6)dF , . . . , dF (cid:7)},δ(x1, . . . , xm) =(cid:7)ψ(x1, x2, x3) =0∞ otherwise,μ if (cid:6)x1, x2, x3(cid:7) ∈ {(cid:6)di0, di0, di00otherwise.(cid:7), (cid:6)di0, dF , dF (cid:7)},Note that δ, ψ ∈ ImpR+(F ) ⊂ Γ .We can now construct the instance P ∈ VCSP(Γ ) with variables{X1, . . . , Xm, Y1, . . . , Ym, Z1, . . . , Zm}and constraints(cid:8)(cid:6)X1, . . . , Xm(cid:7), φ(cid:9)(cid:8)(cid:6)Y1, . . . , Ym(cid:7), δ,(cid:7), ψ(cid:6)Xi0, Yi0 , Zi0(cid:8),(cid:9).(cid:9)(cid:8)(cid:9)(cid:6)X1, . . . , Xm(cid:7), δ(cid:9)(cid:8)(cid:6)Z1, . . . , Zm(cid:7), δ,,996D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016If we set W = (cid:6)Yi0, Zi0(cid:7), then it is straightforward to check that(cid:11)ΦWP (x, y) =φ(d1, d2, . . . , dm)μ + φ(d1, d2, . . . , dm)∞if x (cid:11)= y ∧ x, y ∈ {dF , di0if x = y ∧ x, y ∈ {dF , di0otherwise.},},Hence, by Proposition 5.1, VCSP(Γ ) is NP-hard. (cid:2)Example 6.5. Recall from Example 2.9 that the MAX-SAT optimisation problem has just three maximal tractableclasses, which are identified in [10]. Two of these can be characterised by having a constant function as a multimor-phism; these are referred to in [10] as ‘0-valid’ relations, and ‘1-valid’ relations.26.2. The multimorphism (cid:6)Min, Max(cid:7)The next example we consider is the family of valued constraint languages over a set D characterised by the pres-ence of a single binary multimorphism, (cid:6)Min, Max(cid:7), where the binary operations Min and Max return the minimumand maximum values with respect to some fixed total ordering of D. These languages include the class of submodularset functions used in economics and operations research [39] (see Example 4.6).Lemma 6.6. Let D be a finite totally ordered set. A function φ : Dm → R+ has the multimorphism (cid:6)Min, Max(cid:7) if andonly if it satisfies the following two conditions:• φ is finitely submodular, that is, for all m-tuples s, t, such that φ(s), φ(t) < ∞, we have that(cid:5)(cid:4)Min(s, t)φ(cid:5)(cid:4)Max(s, t)+ φ(cid:2) φ(s) + φ(t),where the operations Min and Max are applied coordinatewise.• Feas(φ) has the polymorphisms Min and Max.Proof. If φ has the multimorphism (cid:6)Min, Max(cid:7), then these two properties follow immediately from Definition 4.3and Proposition 4.10.Conversely, if φ is finitely submodular, then it satisfies Eq. (1) of Definition 4.3 for all choices of t1 and t2. (cid:2)The second condition in Lemma 6.6 implies that the set of m-tuples on which φ is finite is a sublattice of the setof all m-tuples, where the lattice operations are the operations Min and Max applied coordinatewise. Theorem 49.2of [45] implies that any real-valued submodular function defined on such a sublattice can be extended to a submodularfunction on the full lattice. Hence, by Lemma 6.6, any function with the multimorphism (cid:6)Min, Max(cid:7) can be expressedas the sum of a finite-valued submodular function, and a crisp function φR associated with a relation R which has thepolymorphisms Min and Max.Theorem 6.7. Let D be a finite totally ordered set, and let F : D2 → D2 be the function defined by F (d, d (cid:10)) =(cid:6)Min(d, d(cid:10)), Max(d, d (cid:10))(cid:7).1. The set of functions ImpR+(F ) is a tractable valued constraint language.2. Any valued constraint language Γ such that Γ ⊃ ImpR+(F ) is NP-hard.Proof. Assume for simplicity that D = {0, 1, 2, . . . , |D| − 1} with the usual ordering.1. To establish the tractability of the set of functions in ImpR+ (F ), we show that this problem can be reduced tothe problem of minimising a real-valued submodular set function [39] over a special family of sets known as a ringfamily [44]. This problem can then be solved in polynomial time using an algorithm due to Schrijver [44].Let P = (V , D, C, R+) be any instance of VCSP(ImpR+ (F )). By Lemma 6.6, the feasibility relation correspondingto each constraint in P has the polymorphisms Min and Max. Hence the standard constraint satisfaction problem2 The third tractable class for the MAX-SAT problem is discussed in Example 6.8, below.D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016997instance with these relations as crisp constraints can be solved in polynomial time, using the results of [29]. But thismeans that we can determine in polynomial-time whether or not there is an assignment for P with finite cost.If every assignment for P has infinite cost, then we can return an arbitrary assignment as a solution, and we aredone.Otherwise, we define the set Q = D × V , and associate each assignment s for P that has finite cost with a subsetQs of Q, defined as follows:(cid:13)(cid:12)(cid:6)d, v(cid:7) ∈ Q | v ∈ V ∧ d (cid:2) s(v).Qs =Now, it is straightforward to check that for any pair of assignments s and t with finite cost we haveQs ∪ Qt = QMax(s,t),Qs ∩ Qt = QMin(s,t).Hence the subsets of Q associated with the assignments of finite cost form a collection C which is closed under unionand intersection. Such a collection is referred to in [44] as a ring family.Finally, we define the real-valued function ψ on C, by settingψ(Qs) = CostP (s).Note that, since F is a multimorphism of every cost function in P, for all S, T ∈ C we haveψ(S ∪ T ) + ψ(S ∩ T ) (cid:2) ψ(S) + ψ(T ).Hence, ψ is a real-valued submodular set function defined on the finite ring family C, and so can be minimised inpolynomial-time, using the algorithm described in [44]. The output of this algorithm is an element Qs of C corre-sponding to a solution s to P, so the problem is tractable.2. Now assume that Γ ⊃ ImpR+(F ), and hence Γ contains a function φ of some arity m such that F is not amultimorphism of φ. Hence, there exist s, s(cid:10) ∈ Dm such that(cid:4)Min(s, s(cid:10)(cid:5))φ(cid:4)+ φMax(s, s(cid:10)> φ(s) + φ(s(cid:10)),(cid:5))where the operators Min and Max are applied coordinatewise to the tuples s and s(cid:10).It follows that we can find indexes i and j for which s[i] > s(cid:10)[i] and s[j ] < s(cid:10)[j ].We define an m-ary function δ which takes the value 0 on the tuples s, s(cid:10), Max(s, s(cid:10)) and Min(s, s(cid:10)), and ∞ in allother cases. Note that δ ∈ ImpR+ (F ) ⊂ Γ .Define λ and μ as follows:(cid:4)(cid:5)Min(s, s)(cid:4)(cid:10)Max(s, s(cid:4)λ = minφ(cid:4)μ = minφ(cid:10), φ(s) + φ(s(cid:5), φ(s) + φ(s)(cid:10)(cid:5),(cid:5).) + 1(cid:10)) + 1It is straightforward to check that φ(s) + φ(s(cid:10)) < λ + μ < ∞.Now define the binary functionsζ (x, y) =κ(x, y) =(cid:11)⎧⎪⎪⎪⎨⎪⎪⎪⎩μ if (x, y) = (0, s(cid:10)[i]),if (x, y) = (1, s[i]),λ∞ otherwise,0φ(s(cid:10)) + 1φ(s) + 10∞if (x, y) = (s[j ], 0),if (x, y) = (s[j ], 1),if (x, y) = (s(cid:10)[j ], 0),if (x, y) = (s(cid:10)[j ], 1),otherwise.Note that ζ, κ ∈ ImpR+(F ) ⊂ Γ .We can now construct the instance P ∈ VCSP(Γ ) with variables{X, Y, V1, . . . , Vm, W1, . . . , Wm, }998D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016and constraints(cid:8)(cid:9),(cid:9),(cid:8)(cid:6)V1, . . . , Vm(cid:7), δ(cid:8)(cid:6)V1, . . . , Vm(cid:7), φ(cid:6)Wi, X(cid:7), κ(cid:9)(cid:6)X, Vi(cid:7), ζ,,(cid:9)(cid:8)(cid:9),(cid:9),(cid:8)(cid:6)W1, . . . , Wm(cid:7), δ(cid:8)(cid:6)W1, . . . , Wm(cid:7), φ(cid:8)(cid:6)Vj , Y (cid:7), κ(cid:6)Y, Wj (cid:7), ζ,(cid:9).(cid:9)(cid:8)If we set W = (cid:6)X, Y (cid:7), then it is straightforward to check thatλ + μ + φ(s) + φ(s(cid:10))λ + μ + λ + μ∞if x (cid:11)= y ∧ x, y ∈ {0, 1},if x = y ∧ x, y ∈ {0, 1},otherwise.P (x, y) =ΦW(cid:11)Hence, by Proposition 5.1, VCSP(Γ ) is NP-hard. (cid:2)Example 6.8. Recall from Example 2.9 that the MAX-SAT optimisation problem has just three maximal tractableclasses, which are identified in [10]. Two of these can be characterised by having a constant multimorphism (seeExample 6.5). The third can be characterised by having the multimorphism (cid:6)Min, Max(cid:7); this class is referred to in [10]as the class of ‘2-monotone’ relations, where it is defined as the class of relations definable by a logical expression ofthe form (x1 ∧ x2 ∧ · · · ∧ xp) ∨ (y1 ∧ y2 ∧ · · · ∧ yq ) (where the x and y variables are not necessarily distinct).Example 6.9. It follows from Lemma 4.9 and Example 4.8 that every unary function has the multimorphism(cid:6)Min, Max(cid:7).Example 6.10. Let D = {0, 1, . . . , M} be a set of integers. It follows from Example 6.9 and Theorem 4.5 that thelanguage ΓLIN defined in Example 3.3, consisting of all functions on D defined by linear expressions with positiveinteger coefficients, also has the multimorphism (cid:6)Min, Max(cid:7).Example 6.11. A function φ : {0, 1}m → R is called a pseudo-Boolean function [3]. It is straightforward to check fromthe table of values that the function φ defined by φ(x, y) = x(1 − y) has the multimorphism (cid:6)Min, Max(cid:7). It followsfrom Example 6.10 and Theorem 4.5 that the language Γ consisting of non-negative functions on {0, 1} defined byexpressions of the form a0 +i,j aij xixj , where the ai and aij are non-negative integers, also has themultimorphism (cid:6)Min, Max(cid:7), and so is tractable by Theorem 6.7.i aixi −(cid:18)(cid:18)Example 6.12. It was shown in Example 2.6 that the MINIMUM k-TERMINAL CUT problem can be formu-lated as an instance of VCSP(Γk) for a language Γk consisting of crisp unary constraints and the cost functionφEQ : {0, 1, . . . , k}2 → R+ defined in Example 2.6.In the special case when k = 2, it is straightforward to verify that the cost function φEQ has the multimorphism(cid:6)Min, Max(cid:7). Using this fact, and Example 6.9, Theorem 6.7 implies that the MIN-CUT problem can be solved inpolynomial time. (Compare with Example 2.11.)Example 6.13. It follows immediately from Definition 4.3 that a binary function φ : D2 → R+ has the multimorphism(cid:6)Min, Max(cid:7) if and only if, for all u, v, x, y ∈ D, with u < x and v < y, we have φ(u, v) + φ(x, y) (cid:2) φ(u, y) + φ(x, v).Using this observation, it is straightforward to check that for any finite set of real values D the following binaryfunctions all have the multimorphism (cid:6)Min, Max(cid:7), and hence any VCSP instance involving constraints with costfunctions of these forms is tractable.(cid:10)if ax (cid:2) by + c (for constants a, b, c with a, b > 0),δ(x, y) =0∞ otherwise,(cid:19)x2 + y2,η(x, y) =ζ (x, y) = |x − y|r(for r (cid:3) 1).Using these observations, and Example 6.9, we conclude that the discrete optimisation problem described in Exam-ple 1.1 can be solved in polynomial time. (A more specialised algorithm for binary soft constraints of these kinds,which runs in cubic time, is given in our previous paper [7].)D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10169996.3. The multimorphism (cid:6)Max, Max(cid:7)The next example we consider is the family of valued constraint languages over a set D characterised by thepresence of a single binary multimorphism, (cid:6)Max, Max(cid:7), where the binary operation Max returns the maximum valuewith respect to some fixed total ordering of D. These languages generalise the crisp “max-closed” constraint languagesintroduced and shown to be tractable in [29].We first show that any function with values in R+ which has the multimorphism (cid:6)Max, Max(cid:7) satisfies some simpleconditions. For any tuples u, v over an ordered set D, we will write u (cid:2) v if and only if u[i] (cid:2) v[i] for each coordinateposition i.Lemma 6.14. A function φ : Dk → R+ has the multimorphism F : D2 → D2, where F (d, d (cid:10)) = (cid:6)Max(d, d (cid:10)),Max(d, d (cid:10))(cid:7) if and only if it satisfies the following two conditions:• φ is finitely antitone, that is, for all tuples u, v with φ(u), φ(v) < ∞,u (cid:2) v ⇒ φ(u) (cid:3) φ(v).• Feas(φ) has the polymorphism Max.Proof. If φ has the multimorphism F , then for all tuples u, v we have φ(u) + φ(v) (cid:3) 2φ(Max(u, v)), which impliesthat both conditions hold.Conversely, if φ does not have the multimorphism F , then there exist tuples u, w such that φ(u) + φ(w) <2φ(Max(u, w)). Hence, without loss of generality, we may assume that φ(u) < φ(Max(u, w)). Setting v = Max(u, w)we get u < v and φ(u) < φ(v). If φ(v) < ∞ then the first condition in the lemma does not hold, and if φ(v) = ∞,then the second condition fails to hold. (cid:2)By Lemma 6.14, any function with the multimorphism (cid:6)Max, Max(cid:7) can be expressed as the sum of a finite-valuedantitone function, and a crisp function φR associated with a relation R which has the polymorphism Max.Theorem 6.15. Let D be a totally ordered finite set, and let F : D2 → D2 be the function defined by F (d, d (cid:10)) =(cid:6)Max(d, d(cid:10)), Max(d, d (cid:10))(cid:7).1. The set of functions ImpR+(F ) is a tractable valued constraint language.2. Any valued constraint language Γ such that Γ ⊃ ImpR+ (F ) is NP-hard.Proof. Assume for simplicity that D = {0, 1, 2, . . . , |D| − 1} with the usual ordering.1. To establish the tractability of ImpR+(F ), we will give an explicit polynomial-time algorithm for VCSP(Γ ) forany fixed finite subset of ImpR+ (F ).Let Γ be a finite subset of ImpR+(F ), and let P = (V , D, C, R+) be any instance of VCSP(Γ ). To each constraintc = (cid:6)σ, φ(cid:7) ∈ C we can associate a crisp constraint ¯c = (cid:6)σ, Feas(φ)(cid:7) which allows precisely those tuples of values t forwhich φ(t) < ∞. We can then establish arc consistency [37] in the constraint satisfaction problem formed by theseassociated crisp constraints. This is done by successively removing values from the domain of each variable if theyare unsupported, that is, they cannot be extended to compatible values for all the other variables in the scope of eachconstraint containing v. Since Γ is finite, the arity of the constraint relations is bounded, so arc-consistency can beachieved in polynomial time [37].For each variable v, let Dv be the domain of v after establishing arc consistency. If any of these domains are empty,then any assignment for P has cost ∞, and so any assignment is a solution. Otherwise, let ¯dv be the largest supportedvalue for variable v. These values can be computed in polynomial timeBy Lemma 6.14, each constraint of P is finitely antitone, so assigning ¯dv to each variable v is an optimal solutionto P.2. Now assume that Γ ⊃ ImpR+(F ), and hence Γ contains a function φ of some arity m such that F is not amultimorphism of φ. Hence, there exist s, s(cid:10) ∈ Dm such that> φ(s) + φ(s(cid:4)Max(s, s(cid:5))2φ),(cid:10)(cid:10)1000D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016which s[i0] < s(cid:10)(cid:10)[i0].δ ∈ ImpR+ (F ) ⊂ Γ .(cid:11)ψ(x, y) =where the operator Max is applied coordinatewise to the tuples s and s(cid:10).Set s(cid:10)(cid:10) = Max(s, s(cid:10)). We have to consider two cases depending on whether or not φ(s(cid:10)(cid:10)) has cost ∞.Case 1: φ(s(cid:10)(cid:10)) < ∞.Without loss of generality we may assume that φ(s(cid:10)(cid:10)) > φ(s). In this case there must be at least one index i0 forWe define an m-ary function δ which takes the value 0 on the tuples s and s(cid:10)(cid:10), and ∞ in all other cases. Note thatWe also define the binary function ψ as follows2φ(s(cid:10)(cid:10))2φ(s)∞if (cid:6)x, y(cid:7) = (cid:6)s[i0], s[i0](cid:7),if (cid:6)x, y(cid:7) ∈ {(cid:6)s[i0], s(cid:10)(cid:10)[i0](cid:7), (cid:6)s(cid:10)(cid:10)[i0], s[i0](cid:7), (cid:6)s(cid:10)(cid:10)[i0], s(cid:10)(cid:10)[i0](cid:7)},otherwise.Note that ψ ∈ ImpR+ (F ) ⊂ Γ .We can now construct the instance P ∈ VCSP(Γ ) with variables{X1, . . . , Xm, Y1, . . . , Ym}(cid:9)(cid:8),,(cid:8)(cid:6)Y1, . . . , Ym(cid:7), φ(cid:9)(cid:6)Y1, . . . , Ym(cid:7), δ,,(cid:9)and constraints(cid:8)(cid:6)X1, . . . , Xm(cid:7), φ(cid:8)(cid:9)(cid:6)X1, . . . , Xm(cid:7), δ(cid:8)(cid:6)Xi0, Yi0If we set W = (cid:6)Xi0, Yi0(cid:7), ψ.(cid:9)(cid:11)(cid:7), then it is straightforward to check thatΦWP (x, y) =if x (cid:11)= y ∧ x, y ∈ {s[i0], s(cid:10)(cid:10)[i0]},if x = y ∧ x, y ∈ {s[i0], s(cid:10)(cid:10)[i0]},otherwise.Hence, by Proposition 5.1, VCSP(Γ ) is NP-hard.φ(s(cid:10)(cid:10)) + 3φ(s)2(φ(s(cid:10)(cid:10)) + φ(s))∞Case 2: φ(s(cid:10)(cid:10)) = ∞.Consider the relation Feas(φ) containing precisely those tuples for which the value of φ is finite. Since, by hypoth-esis, φ(s), φ(s(cid:10)) < ∞ and φ(s(cid:10)(cid:10)) = ∞, we have s, s(cid:10) ∈ Feas(φ) and s(cid:10)(cid:10) = Max(s, s(cid:10)) (cid:11)∈ Feas(φ). That is, the relationFeas(φ) does not have the polymorphism Max.Now let LMax be the crisp constraint language over D consisting of all relations which do have the polymorphismMax. It was shown in [29] that LMax is a maximal tractable language, and hence the class of crisp constraint sat-isfaction problems with constraint relations chosen from LMax ∪ {Feas(φ)} is NP-complete. By representing thesecrisp constraints as valued constraints with the corresponding feasibility functions as cost functions, as described inExample 2.4, we can obtain a polynomial-time reduction from this problem to the decision problem associated withVCSP(Γ ). Hence VCSP(Γ ) is NP-hard. (cid:2)Example 6.16. Let D = {0, 1, 2, . . . , M} be a subset of the integers, and let ΓAT be the set of all antitone cost functionsover D with costs in R+ \ {∞}. These cost functions can be used to express a preference for larger values of theirx2 + y2 + z2, can be used to selectarguments. For example, the ternary function φ, defined by φ(x, y, z) = 3M −a point in D3 which is as far as possible from the origin. By Lemma 6.14, ΓAT has the multimorphism (cid:6)Max, Max(cid:7),and hence is tractable by Theorem 6.15(cid:20)Example 6.17. The constraint programming language CHIP [47] incorporates a number of constraint solving tech-niques for arithmetic and other constraints. In particular it provides a constraint solver for a restricted class of crispconstraints over natural numbers, referred to as basic constraints. These basic constraints are of two kinds which arereferred to as “domain constraints” and “arithmetic constraints”. The domain constraints are unary constraints whichrestrict the value of a variable to some specified finite subset of the natural numbers. The arithmetic constraints areunary or binary constraints which have one of the following forms:aX (cid:11)= b,aX = bY + c,D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10161001aX (cid:2) bY + c,aX (cid:3) bY + c,where variables are represented by upper-case letters, and constants by lower case letters. All constants are non-negative, and a is non-zero.If we represent these crisp constraints as valued constraints with the corresponding feasibility functions as costfunctions, as described in Example 2.4, then it is easy to verify that they all have the multimorphism (cid:6)Max, Max(cid:7), andhence form a tractable valued constraint language, by Theorem 6.15.Moreover, this tractable language can be extended, as shown in [29], to also include the feasibility functions of thefollowing non-binary relations, which also have the multimorphism (cid:6)Max, Max(cid:7).a1X1 + a2X2 + · · · + ar Xr (cid:3) bY + c,aX1X2 . . . Xr (cid:3) bY + c,(a1X1 (cid:3) b1) ∨ (a2X2 (cid:3) b2) ∨ · · · ∨ (ar Xr (cid:3) br ) ∨ (aY (cid:2) b).The tractable language consisting of all crisp constraint functions with the multimorphism (cid:6)Max, Max(cid:7) will bedenoted ΓMC.Example 6.18. By Lemma 6.14 and Theorem 3.4, we can combine the tractable languages ΓAT (defined in Exam-ple 6.16) and ΓMC (defined in Example 6.17) to obtain the much larger tractable language (ΓAT ∪ ΓMC)∗. In fact, wehave ImpR+ ((cid:6)Max, Max(cid:7)) = (ΓAT ∪ ΓMC)∗.This larger tractable language includes functions such as the binary function φ : D2 → R+ defined by(cid:10)φ(x, y) =(M − x)(M − y)∞if x < y,if x (cid:3) y.This function can be expressed as the sum of the antitone function ψ(x, y) = (M − x)(M − y), and the function φR< ,where R< = {(cid:6)x, y(cid:7) | x < y}. It can be used to express a preference for larger values for x, y provided x < y.6.4. Majority and minority multimorphismsThe next example we consider is the family of valued constraint languages over a set D characterised by thepresence of a single ternary multimorphism, (cid:6)F1, F2, F3(cid:7), where each component function Fi is a majority operation,defined as follows.Definition 6.19. A function f : D3 → D is called a majority operation if, for all x, y ∈ D,f (x, x, y) = f (x, y, x) = f (y, x, x) = x.Languages with a multimorphism of this kind can be shown to be essentially crisp, and hence their complexity can bedetermined by using techniques developed for the standard constraint satisfaction problem with crisp constraints. Infact, problems involving such languages can be viewed as a generalisation of the standard tractable 2-SATISFIABILITYproblem to larger finite domains.Proposition 6.20. Any valued constraint language with costs in R+ which has a multimorphism (cid:6)F1, F2, F3(cid:7), whereeach Fi is a majority operation, is an essentially crisp language, and is tractable.Proof. Let Γ be a valued constraint language which has the multimorphism (cid:6)F1, F2, F3(cid:7), and let φ be a k-ary costfunction in Γ .If each Fi is a majority operation, then it follows from Definitions 6.19 and 4.3 that for all x, y ∈ Dk, 3φ(x) (cid:2)φ(x) + φ(x) + φ(y) and 3φ(y) (cid:2) φ(y) + φ(y) + φ(x). Hence, if both φ(x) and φ(y) are finite, then we haveφ(x) (cid:2) φ(y) and φ(y) (cid:2) φ(x), so they must be equal, which means that φ is essentially crisp.Furthermore, for each φ ∈ Γ , the relation Feas(φ) has the polymorphism F1, which is a majority operation, so itfollows from Theorem 5.7 of [26] that VCSP(Γ ) is tractable. (cid:2)1002D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016Similar arguments can be used for minority operations, defined as follows:Definition 6.21. A function f : D3 → D is called a minority operation if, for all x, y ∈ D,f (x, x, y) = f (x, y, x) = f (y, x, x) = y.Proposition 6.22. Any valued constraint language with costs in R+ which has a multimorphism (cid:6)F1, F2, F3(cid:7), whereeach Fi is a minority operation, is an essentially crisp language, and is tractable.Proof. Let Γ be a valued constraint language which has the multimorphism (cid:6)F1, F2, F3(cid:7), and let φ be a k-ary costfunction in Γ .If each Fi is a minority operation, then for all x, y ∈ Dk, we have 3φ(x) (cid:2) φ(x) + φ(y) + φ(y) and 3φ(y) (cid:2)φ(y) + φ(x) + φ(x). Hence, if both φ(x) and φ(y) are finite, then we have φ(x) (cid:2) φ(y) and φ(y) (cid:2) φ(x), so theymust be equal, which means that φ is essentially crisp.Furthermore, for each φ ∈ Γ , the relation Feas(φ) has the polymorphism F1, which is a minority operation, andhence a Mal’tsev operation (see [13]), so it follows from Theorem 1 of [13] that VCSP(Γ ) is tractable. (cid:2)6.5. The multimorphism (cid:6)Mjrty1, Mjrty2, Mnrty3(cid:7)The final example we consider is the valued constraint language with costs in R+ which is characterised by the(cid:7), where(cid:10)yxMjrty1(x, y, z) =presence of the single ternary multimorphism (cid:6)Mjrty1, Mjrty2, Mnrty3if y = z,otherwise,if x = z,otherwise,if y = z ∧ z (cid:11)= x,if x = z ∧ z (cid:11)= y,otherwise.Mnrty3(x, y, z) =Mjrty2(x, y, z) =xy(cid:11)xyz(cid:10)Note that Mjrty1 and Mjrty2 are both majority operations3 and Mnrty3 is a minority operation (see Definitions 6.19and 6.21).We will show in this section that any function taking values in R+ which has this multimorphism has a very simpleform. The proof of this fact is rather involved, but we include it here largely because the result turns out to be essentialfor the complete classification of the Boolean case in Section 7. Despite the simplicity of the associated constraintlanguage, we will show that this multimorphism again defines a maximal tractable class.We first need a technical lemma. For any m-tuple s over a set D, we will write s[i ← d] to denote the tuple withd ∈ D substituted at position i. In other words, s[i ← d] is the m-tuple which is identical to s except (possibly) atposition i, where it is equal to d.Lemma 6.23. A function φ : Dm → R+ can be expressed as a sum of unary functions if and only if, for all tupless, t ∈ Dm, and all i = 1, . . . , m we have that(cid:21)(cid:4)i ← s[i]sφ(s) + φ(t) = φi ← t[i](cid:22)(cid:5).+ φ(cid:4)t(cid:22)(cid:5)(7)(cid:21)Proof. Suppose that φ can be expressed as a sum of unary functions. This means there exist φ1, . . . , φm such that, forall tuples s = (cid:6)s1, . . . , sm(cid:7) and t = (cid:6)t1, . . . , tm(cid:7),m(cid:2)(cid:4)(cid:5)φi(si) + φi(ti)φ(s) + φ(t) =.i=1By rearranging the terms in the summation we get Eq. (7).3 The operation Mjrty1 is sometimes known as the dual discriminator operation [46].D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10161003Conversely, suppose that φ satisfies Eq. (7). We will now show that this implies that φ can be expressed as a sumof unary functions.Let s0 = (cid:6)s01, . . . , s0m(cid:7) be an m-tuple on which φ achieves its minimum cost, that is∀s ∈ Dm, φ(s0) (cid:2) φ(s).If φ(s0) = ∞ then φ never takes a finite value so φ(x1, . . . , xm) =So we may assume that φ(s0) < ∞.For i = 1, . . . , m, let μi be the unary cost function defined by(cid:12)φ(x1, . . . , xm) | xi = xμi(x) = min(cid:13)(cid:18)(8)mi=1 ζ (xi) where ζ (x) = ∞ and the result holds.and for each x ∈ D choose a witness wxi∈ Dm such that wxiNote that for all tuples (cid:6)x1, . . . , xm(cid:7) with xi = x, we have[i] = x, and φ(wxi ) = μi(x).μi(x) (cid:2) φ(x1, . . . , xm).We now have, for all x ∈ D,μi(x) + φ(s0) = φ(wx(cid:4)wx= φi(cid:4)wx= φi(cid:3) φ(s0) + φso μi(x) (cid:3) φbut μi(x) (cid:2) φand so μi(x) = φi ) + φ(s0)(cid:21)(cid:5)(cid:4)i ← wx[i ← s0i]+ φs0i(cid:5)(cid:5)(cid:4)s0[i ← x]+ φ[i ← s0i](cid:5)(cid:4)s0[i ← x](cid:5)(cid:4)s0[i ← x](cid:5)(cid:4)s0[i ← x](cid:5)(cid:4)s0[i ← x].(9)(cid:22)(cid:5)[i]by choice of wxiby Eq. (7)by choice of wxiby Eq. (8)cancelling φ(s0) < ∞by Eq. (9)Now consider an arbitrary tuple s = (cid:6)x1, . . . , xm(cid:7). By applying Eq. (7) m − 1 times we obtain:(cid:5)(cid:4)s0[i ← xi]φ(s) + (m − 1)φ(s0) =μi(xi).m(cid:2)m(cid:2)=φi=1i=1Eq. (8) ensures that choosing φi(x) = μi(x) − φ(s0), i = 2, . . . , m, is well defined. Finally, choosing φ1(x) = μ1(x)gives the result. (cid:2)Using this result we now show that any function which has the multimorphism (cid:6)Mjrty1, Mjrty2, Mnrty3expressed as a sum of unary functions and binary functions of the following kind.(cid:7) can beDefinition 6.24. Let D be a set, and Ω a valuation structure. A crisp binary function φ : D2 → Ω will be called apermutation restriction if∀x ∈ D,y | φ(x, y) = 0(cid:23)(cid:12)(cid:23)(cid:13)(cid:23)(cid:23) (cid:2) 1 and(cid:23)(cid:23)(cid:12)y | φ(y, x) = 0(cid:13)(cid:23)(cid:23) (cid:2) 1.Theorem 6.25. Let D be a finite set, and let F : D3 → D3 be the function defined by F (x, y, z) = (cid:6)Mjrty1(x, y, z),Mjrty2(x, y, z), Mnrty3(x, y, z)(cid:7).A k-ary function φ belongs to the set ImpR+ (F ) if and only if it can be expressed as a sum of unary functions andpermutation restrictions.Proof. By Theorem 4.5, to show that any function which can be expressed as the sum of unary functions and permu-tation restrictions is in ImpR+(F ) it is sufficient to show that all unary functions and all permutation restrictions arein ImpR+ (F ).Since F is conservative, we know by Lemma 4.9 that F is a multimorphism of all unary functions.Now let π be an arbitrary permutation restriction, and consider the arbitrary triples t1, t2 ∈ D3. If any(cid:24)(cid:24)33π(t1[i], t2[i]) = ∞ then F trivially satisfies the inequalityi=1 π(t1[i], t2[i]), so con-i=1 π(F (t1)[i], F (t2)[i]) (cid:2)sider the case where each π(t1[i], t2[i]) < ∞. In this case each t2[i] is determined by the corresponding t1[i], because1004D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016π is a permutation restriction. Suppose that two of the pairs (cid:6)t1[i], t2[i](cid:7) are equal, say they are both (cid:6)p, q(cid:7), andthat the third pair is (cid:6)r, s(cid:7). Then, by the definition of F , we have that (cid:6)F (t1)[1], F (t2)[1](cid:7) = (cid:6)F (t1)[2], F (t2)[2](cid:7) =3(cid:6)p, q(cid:7) and that (cid:6)F (t1)[3], F (t2)[3](cid:7) = (cid:6)r, s(cid:7), so F again satisfies the inequalityi=1 π(F (t1)[i], F (t2)[i]) (cid:2)(cid:24)3i=1 π(t1[i], t2[i]) (with equality). The only remaining case to consider is when each pair (cid:6)t1[i], t2[i](cid:7) is dis-in this case the definition of F gives (cid:6)F (t1)[i], F (t2)[i](cid:7) = (cid:6)t1[i], t2[i](cid:7), i = 1, 2, 3, and so againtinct, but(cid:24)3i=1 π(F (t1)[i], F (t2)[i]) = π(t1[i], t2[i]). Hence F is a multimorphism of any permutation restriction.Conversely, suppose that φ is a k-ary function in ImpR+(F ). In the remainder of the proof we shall establish that(cid:24)φ can be expressed as a sum of unary functions and permutation restrictions.Consider the k-ary relation Feas(φ). It follows from Proposition 4.10 that Feas(φ) must have the three polymor-phisms Mjrty1, Mjrty2 and Mnrty3. Any relation with a majority operation (such as Mjrty1) as a polymorphism isknown to be decomposable into its binary projections [25,46]. This means that (cid:6)x1, . . . , xk(cid:7) ∈ Feas(φ) exactly when∀i, j ∈ {1, . . . , k},(cid:6)xi, xj (cid:7) ∈ Rij ,whereRij =(cid:12)(cid:13)(cid:6)xi, xj (cid:7) | ∃(cid:6)x1, x2, . . . , xk(cid:7) ∈ Feas(φ).Furthermore, polymorphisms are preserved under taking projections [26], so each of the binary relations Rij alsohas the three polymorphisms Mjrty1, Mjrty2 and Mnrty3.Binary relations with the polymorphism Mjrty1 have previously been characterised [46], and any such relation isknown to have one of the following forms:• Feas(μ1 + μ2), where μ1, μ2 are unary functions;• Feas(π), where π is a permutation restriction;• {(cid:6)x, y(cid:7) ∈ D1 × D2 | (x = d1) ∨ (y = d2)}, for some d1, d2 ∈ D, and some D1, D2 ⊆ D with |D1| > 1 and |D2| > 1.Of these three, it is straightforward to check that only the first two have Mnrty3 as a polymorphism. Therefore φ canbe expressed as a sum of functions of the following form:(cid:2)(cid:2)φ(x1, . . . , xk) = ψ(x1, . . . , xk) +πi(xai , xbi ) +μj (xcj ),(10)i∈Ij ∈Jwhere ψ is a cost function taking only finite values, each πi is a permutation restriction, and each μj is a crisp unaryfunction.Let G be the graph with vertices {1, . . . , k} and edges {(cid:6)ai, bi(cid:7) | i ∈ I }. Choose a set M = {m1, . . . , mr } containingone representative from each connected component of G, and define the function η as follows:(cid:12)η(y1, . . . , yr ) def= minφ(x1, . . . , xk) | xmi(11)By the choice of M, every vertex 1, . . . , k is connected in G to exactly one mi . Hence, for any (cid:6)y1, . . . , yr (cid:7) ∈ Dr , wehave.= yi, i = 1, . . . , r(cid:13)(cid:12)(cid:23)(cid:23)(cid:6)x1, . . . , xk(cid:7) | φ(x1, . . . , xk) < ∞ and xmiLet (cid:6)x1, . . . , xk(cid:7) ∈ Dk, and set (cid:6)y1, . . . , yr (cid:7) = (cid:6)xm1, . . . , xmrwith equality if φ(x1, . . . , xk) is finite.= yi, i = 1, . . . , r(cid:13)(cid:23)(cid:23) (cid:2) 1.(cid:7). We have, by Eq. (12), that η(y1, . . . , yr ) (cid:2) φ(x1, . . . , xk),(12)It only remains to prove that η can be expressed as a sum of unary functions. Let 1 (cid:2) j (cid:2) r and s = (cid:6)s1, . . . , sr (cid:7), t =(cid:6)t1, . . . , tr (cid:7) ∈ Dr .First suppose that η(s), η(t) < ∞. Since φ ∈ ImpR+(F ), and η is expressible over {φ}, we know by Theorem 4.5that η ∈ ImpR+ (F ), and hence(cid:5)(cid:4)+ ηt[j ← sj ]η(s) + η(cid:5)(cid:4)s[j ← tj ](cid:3) η(s) + η(s) + η(t).Cancelling η(s) < ∞, and using symmetry, we obtain,(cid:5)(cid:4)s[j ← tj ]η(cid:5)(cid:4)t[j ← sj ]+ η= η(s) + η(t).(13)D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10161005Otherwise, without loss of generality we may assume that η(s) = ∞, and hence φ(x1, . . . , xk) = ∞ for(cid:7) = s. Using Eq. (10), this implies there is some single index i such that= si . Hence Eq. (13) holds in this case also, since both sides equal ∞.all x1, . . . , xk with (cid:6)xm1, . . . , xmrφ(x1, . . . , xk) = ∞ for all x1, . . . , xk with xmiHence, in all cases, by Lemma 6.23, η can be expressed as a sum of unary functions. (cid:2)Corollary 6.26. A function φ : Dm → R+ has the multimorphism (cid:6)Mjrty1, Mjrty2, Mnrty3the following two conditions:(cid:7) if and only if it satisfies• φ is finitely modular, that is, for all m-tuples s, t, and all i = 1, . . . , m such that φ(s), φ(t), φ(s[i ← t[i]]),φ(t[i ← s[i]]) < ∞, we have thati ← t[i](cid:21)(cid:4)i ← s[i]s• Feas(φ) has the polymorphisms Mjrty1 and Mnrty3.φ(s) + φ(t) = φ+ φ(cid:4)t(cid:22)(cid:5)(cid:21)(cid:22)(cid:5).We will now prove that the set of all functions with the multimorphism (cid:6)Mjrty1, Mjrty2, Mnrty3tractable valued constraint language.(cid:7) is a maximalTheorem 6.27. Let D be a finite set, and let F : D3 → D3 be the function defined by F (x, y, z) = (cid:6)Mjrty1(x, y, z),Mjrty2(x, y, z), Mnrty3(x, y, z)(cid:7).1. The set ImpR+(F ) is a tractable valued constraint language.2. Any valued constraint language Γ such that Γ ⊃ ImpR+ (F ) is NP-hard.Proof. 1. This is a straightforward application of Theorem 6.25. To solve any instance of VCSP(ImpR+(F )) wecan simply merge each pair of variables constrained by a permutation restriction (combining the associated unaryconstraints appropriately). The resulting VCSP instance has only unary constraints and so can be solved trivially.2. Now assume that Γ ⊃ ImpR+(F ), and hence Γ contains a function φ of some arity m such that F is not amultimorphism of φ. By Corollary 6.26, there are 3 cases to consider.Case 1: φ is not finitely modular.In this case, there exist j ∈ {1, . . . , m}, s = (cid:6)s1, . . . , sm(cid:7), and t = (cid:6)t1, . . . , tm(cid:7) ∈ Dm such that(cid:5)(cid:4)t[j ← sj ](cid:5)(cid:4)s[j ← tj ]φ(s) + φ(t) < φ+ φand all values in the inequality are finite.For i = 1, 2, . . . , m, we define the following permutation restrictions:(cid:11)ζi(x, y) =if x = s1, y = si,if x = t1, y = ti,00∞ otherwise,κi(x, y) =if x = s1, y = ti,if x = t1, y = si,00∞ otherwise.(cid:11)Note that each ζi and each κi ∈ ImpR+(F ) ⊂ Γ .We can now construct the instance P ∈ VCSP(Γ ) with variables{X1, . . . , Xm, Y1, . . . , Ym, Z}and constraints(cid:8)(cid:9)(cid:9),(cid:6)X1, Y1(cid:7), κ1(cid:8)(cid:6)X1, . . . , Xm(cid:7), φ(cid:8)(cid:6)Z, Xj (cid:7), κj(cid:8)(cid:6)X1, Xi(cid:7), ζi(cid:8)(cid:9)(cid:6)Y1, Yi(cid:7), ζi,(cid:9)(cid:9),(cid:8)(cid:9)(cid:9),(cid:6)Y1, . . . , Ym(cid:7), φ(cid:8)(cid:6)Z, Yj (cid:7), ζj(i = 1, 2, . . . , j − 1, j + 1, . . . , m),(i = 1, 2, . . . , j − 1, j + 1, . . . , m).,If we set W = (cid:6)X1, Z(cid:7), then it is straightforward to check that(cid:11)ΦWP (x, y) =φ(s) + φ(t)φ(s[j ← tj ]) + φ(t[j ← sj ])∞if x (cid:11)= y ∧ x, y ∈ {s1, t1},if x = y ∧ x, y ∈ {s1, t1},otherwise.1006D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016Hence, by Proposition 5.1, VCSP(Γ ) is NP-hard.Case 2: Feas(φ) does not have the polymorphism Mjrty1.Let Feas(Γ ) = {Feas(ψ) | ψ ∈ Γ }, and let P be the set of all polymorphisms of Feas(Γ ). Since Γ contains allpermutation restrictions, the algebra whose set of operations is P is homogeneous, as defined in [46]. A completedescription of all homogeneous finite algebras is given in Chapter 5 of [46] and it is straightforward to verify4 fromthis that if P does not contain the operation Mjrty1, then every element of P is a polymorphism of the relationR = {(cid:6)d0, d0, d0(cid:7), (cid:6)d0, d1, d1(cid:7), (cid:6)d1, d0, d1(cid:7), (cid:6)d1, d1, d0(cid:7)}, for some d0, d1 ∈ D.Hence, by Theorem 4.10 of [24], the relation R can be expressed using some finite combination of relations fromFeas(Γ ). This implies that Γ ∗ contains a function φ such that φ(s) < ∞ exactly when s ∈ R.Now setα = ψ(d0, d1, d1) + ψ(d1, d0, d1) < ∞,β = ψ(d1, d1, d0) + ψ(d0, d0, d0) < ∞.We define the binary permutation restriction π and the unary function μ as follows:if x = d0, y = d1 or x = d1, y = d0,(cid:10)π(x, y) =(cid:11)μ(x) =0∞ otherwise,α + 1 if x = d0,if x = d1,0∞otherwise.We can now construct the instance P ∈ VCSP(Γ ) with variables{X, Y, Z, X(cid:10), Y(cid:10)}and constraints(cid:8)(cid:6)X, Y, Z(cid:7), ψ(cid:8)(cid:9)(cid:6)X, X(cid:10)(cid:7), π,(cid:6)Z(cid:7), μ.(cid:9)(cid:8)(cid:9),(cid:8)(cid:8)(cid:6)X(cid:10), Y (cid:10), Z(cid:7), ψ(cid:6)Y, Y (cid:10)(cid:7), π,(cid:9)(cid:9),If we set W = (cid:6)X, Y (cid:7), then it is straightforward to check thatif x (cid:11)= y ∧ x, y ∈ {d0, d1},if x = y ∧ x, y ∈ {d0, d1},otherwise.αα + β + 1∞P (x, y) =ΦW(cid:11)Hence, by Proposition 5.1, VCSP(Γ ) is NP-hard.Case 3: Feas(φ) has the polymorphism Mjrty1, but not Mnrty3.As indicated in the proof of Theorem 6.25, relations with the polymorphism Mjrty1 are known to be decomposableinto binary relations of 3 distinct types [46], and the only one of these types which does not have the polymorphismMnrty3 is the set of relations of the form {(cid:6)x, y(cid:7) ∈ D1 × D2 | (x = d1) ∨ (y = d2)}, for some d1, d2 ∈ D, and someD1, D2 ⊆ D with |D1| > 1 and |D2| > 1.Now define the binary relation Rij = {(cid:6)xi, xj (cid:7) | ∃(cid:6)x1, x2, . . . , xm(cid:7) ∈ Feas(φ)}. It follows from the observations justmade that we can choose a pair of indices i and j and a, b, c, d ∈ D with a (cid:11)= b, c (cid:11)= d, such that (cid:6)a, c(cid:7), (cid:6)b, d(cid:7), (cid:6)b, c(cid:7) ∈Rij , and (cid:6)a, d(cid:7) (cid:11)∈ Rij . Hence, if we define the function φ(cid:10) by setting(cid:12)φ(z1, . . . , zm) | x = zi, y = zj(x, y) = min(cid:10)φ(cid:13)then we have φ(cid:10)(a, c), φ(cid:10)(b, d), φ(cid:10)(b, c) < ∞, and φ(cid:10)(a, d) = ∞.Now define the functions:(cid:11)ζ (x) =φ(cid:10)(b, d)if x = a,φ(cid:10)(a, c) + φ(cid:10)(b, d) + 1 if x = b,∞otherwise,4 This is stated explicitly in Lemma 5.6 of [46] for the case when |D| (cid:3) 5; the remaining 3 cases can be checked individually.D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10161007(cid:11)κ(x) =2(φ(cid:10)(b, d) + 1)0∞(cid:7)0∞ otherwise.Note that τ, κ, ζ ∈ ImpR+(F ) ⊂ Γ and φ(cid:10) ∈ Γ ∗.if x = c,if x = d,otherwise,if {x, y} = {a, b},τ (x, y) =We can now construct the instance P ∈ VCSP(Γ ∗) with variables{X, Y, Z, Z}(cid:9),and constraints(cid:8)(cid:9)(cid:6)X, Y (cid:7), φ(cid:10)(cid:8)(cid:6)X(cid:7), ζ(cid:8)(cid:6)Y (cid:7), κ,,(cid:9)(cid:8)(cid:6)Z, Y (cid:7), φ(cid:10)(cid:9)(cid:8)(cid:6)Z(cid:7), ζ,(cid:8)(cid:6)Z, Z(cid:7), τ(cid:9)(cid:9),.If we set W = (cid:6)X, Z(cid:7), then it is straightforward to check that(cid:11)ΦWP (x, y) =2φ(cid:10)(a, c) + 4φ(cid:10)(b, d) + 2if x (cid:11)= y, x, y ∈ {a, b},2φ(cid:10)(a, c) + 4φ(cid:10)(b, d) + φ(cid:10)(b, c) + 3 if x = y, x, y ∈ {a, b},∞otherwise.Hence, by Proposition 5.1, VCSP(Γ ) is NP-hard. (cid:2)7. The Boolean caseRecall from Example 2.9 that a valued constraint language over the set {0, 1} is called a valued Boolean constraintlanguage. In this section we will show that every tractable valued Boolean constraint language with costs in R+ ischaracterised by the presence of a certain form of multimorphism. In fact we establish a dichotomy result: if a valuedBoolean constraint language with costs in R+ has one of eight specified multimorphisms then it is tractable, otherwiseit is NP-hard.Theorem 7.1. Let Γ be a valued Boolean constraint language with costs in R+.If Γ has one of the following multimorphisms then VCSP(Γ ) is tractable:1. (cid:6)0(cid:7), where 0 is the constant unary function returning the value 0;2. (cid:6)1(cid:7), where 1 is the constant unary function returning the value 1;3. (cid:6)Max, Max(cid:7), where Max is the binary function returning the maximum of its arguments (i.e., Max(x, y) = x ∨ y);4. (cid:6)Min, Min(cid:7), where Min is the binary function returning the minimum of its arguments (i.e., Min(x, y) = x ∧ y);5. (cid:6)Min, Max(cid:7);6. (cid:6)Mjrty, Mjrty, Mjrty(cid:7), where Mjrty is the unique ternary majority function on the set {0, 1};7. (cid:6)Mnrty, Mnrty, Mnrty(cid:7), where Mnrty is the unique ternary minority function on the set {0, 1};8. (cid:6)Mjrty, Mjrty, Mnrty(cid:7).In all other cases VCSP(Γ ) is NP-hard.To establish the first part of Theorem 7.1, we must show that a valued Boolean constraint language which has oneof the eight types of multimorphisms listed in the theorem is tractable.The tractability of any valued constraint language which has the multimorphism (cid:6)0(cid:7) or (cid:6)1(cid:7) was established in Theo-rem 6.4. Furthermore, the tractability of any valued constraint language which has the multimorphism (cid:6)Max, Max(cid:7) wasestablished in Theorem 6.15, and a symmetric argument (with the domain ordering reversed) establishes the tractabil-ity of any valued constraint language with the multimorphism (cid:6)Min, Min(cid:7). The tractability of any valued constraintlanguage which has the multimorphism (cid:6)Min, Max(cid:7) was established in Theorem 6.7. The tractability of any valuedconstraint language which has the multimorphism (cid:6)Mjrty, Mjrty, Mjrty(cid:7) was established in Proposition 6.20, and thetractability of any valued constraint language which has the multimorphism (cid:6)Mnrty, Mnrty, Mnrty(cid:7) was established1008D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016in Proposition 6.22. Finally, the tractability of any valued Boolean constraint language which has the multimorphism(cid:6)Mjrty, Mjrty, Mnrty(cid:7) follows immediately from Theorem 6.27.To establish the remaining part of Theorem 7.1, we must show that a valued Boolean constraint language with costsin R+ which does not have any of the types of multimorphisms listed in the theorem is NP-hard. We first deal withessentially crisp languages.Lemma 7.2. Any valued Boolean constraint language which is essentially crisp and does not have any of the multi-morphisms listed in Theorem 7.1 is NP-hard.Proof. If we replace each cost function φ in Γ with the relation Feas(φ) then we obtain a crisp Boolean constraintlanguage Γ (cid:10) which does not have any of the polymorphisms 0, 1, Min, Max, Mjrty or Mnrty.By Schaefer’s Dichotomy Theorem [26,42], Γ (cid:10) is NP-complete, and hence Γ is NP-hard. (cid:2)For the remaining languages, our strategy will be to show that any language which does not have one of themultimorphisms listed in Theorem 7.1 can express certain special functions, which we now define.Definition 7.3.• A unary function σ on the set {0, 1} is a 0-selector ifσ (0) < σ (1)and it is a finite 0-selector if, in addition, σ (1) < ∞.A (finite) 1-selector is defined analogously. A selector is either a 1-selector or a 0-selector.• A binary function φ on the set {0, 1} is a NEQ function ifφ(0, 1) = φ(1, 0) < φ(1, 1) = φ(0, 0) = ∞.• A binary function φ on the set {0, 1} is an XOR function ifφ(0, 1) = φ(1, 0) < φ(1, 1) = φ(0, 0) < ∞.Lemma 7.4. Let Γ be a valued Boolean constraint language with costs in R+ which is not essentially crisp.If Γ ∗ contains a NEQ function, then either Γ ∗ contains both a finite 0-selector and a finite 1-selector, or else Γ ∗contains an XOR function.Proof. Let ν ∈ Γ ∗ be a NEQ function.First we show that if Γ ∗ contains a finite 0-selector σ0, then it also contains a finite 1-selector. To see this, simplyis a finiteconstruct the instance P0 with variables {x, y} and constraints {(cid:6)(cid:6)x(cid:7), σ0(cid:7), (cid:6)(cid:6)x, y(cid:7), ν(cid:7)}, and note that Φ1-selector. Similarly, if Γ ∗ contains a finite 1-selector, then it also contains a finite 0-selector.(cid:6)y(cid:7)P0Now let ζ ∈ Γ be a cost function of arity m which is not essentially crisp. Choose tuples u, v such that ζ (u) and ζ (v)are as small as possible with ζ (u) < ζ (v) < ∞. Let P be the VCSP instance with four variables: {x00, x01, x10, x11},and three constraints:(cid:8)(cid:6)xu[1]v[1], . . . , xu[m]v[m](cid:7), ζLet W = (cid:6)x01, x11(cid:7), and ψ = ΦWP .,(cid:9)(cid:8)(cid:9)(cid:8)(cid:9)(cid:6)x00, x11(cid:7), ν,(cid:6)x01, x10(cid:7), ν.Note that the arity-m cost function ζ is applied to only four variables by repeating arguments. Note also thatψ(0, 1) = ζ (u) + 2ν(0, 1) and ψ(1, 1) = ζ (v) + 2ν(0, 1). If ψ(0, 1) (cid:11)= ψ(1, 0), then, by the choice of u, ψ(0, 1) <(cid:6)x01(cid:7)ψ(1, 0), and ψ(0, 1) < ψ(1, 1) < ∞, so Φis a finite 0-selector.PHence we may assume that ψ(0, 1) = ψ(1, 0). If ψ(0, 0) (cid:11)= ψ(1, 1), then if ψ(0, 0) < ∞ the function ψ(x, x) is afinite selector, and hence Γ ∗ contains both a finite 0-selector and a finite 1-selector. On the other hand, if ψ(0, 0) = ∞then construct the instance P2 with variables {x, y} and constraints {(cid:6)(cid:6)x, x(cid:7), ψ(cid:7), (cid:6)(cid:6)x, y(cid:7), ψ(cid:7)}. In this case Φis afinite 0-selector, and hence Γ ∗ again contains both a finite 0-selector and a finite 1-selector.(cid:6)y(cid:7)P2Otherwise we may assume that ψ(0, 1) = ψ(1, 0) and ψ(0, 0) = ψ(1, 1). By construction, we have ψ(0, 1) =ζ (u) + 2ν(0, 1) < ζ (v) + 2ν(0, 1) = ψ(1, 1) < ∞. So in this case ψ is an XOR function. (cid:2)D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10161009Lemma 7.5. Let Γ be a valued Boolean constraint language with costs in R+ which is not essentially crisp, and doesnot have either of the multimorphisms (cid:6)0(cid:7) or (cid:6)1(cid:7).Either Γ ∗ contains a 0-selector and a 1-selector, or else Γ ∗ contains an XOR function.Proof. Let φ0 ∈ Γ be a function which does not have the multimorphism (cid:6)0(cid:7), and φ1 ∈ Γ be a function which doesnot have the multimorphism (cid:6)1(cid:7), and let m be the arity of φ0. Choose a tuple r such that φ0(r) is the minimal value ofφ0. By the choice of φ0, we have φ0(r) < φ0(0, 0, . . . , 0).Suppose first that Γ ∗ contains a 0-selector σ0. Let M be a finite natural number which is larger than all finitevalues in the range of φ0. We construct the instance P ∈ VCSP(Γ ) with two variables {x0, x1}, and two constraints(cid:6)(cid:6)xr[1], . . . , xr[m](cid:7), φ0(cid:7) and (cid:6)(cid:6)x0(cid:7), Mσ0(cid:7). (The cost function Mσ0 is simply equivalent to taking M copies of a con-(cid:6)x1(cid:7)P (0), and so in this case Γ ∗ containsstraint with cost function σ0.) It is straightforward to check that Φa 1-selector. A similar argument, using φ1, shows that if Γ ∗ contains a 1-selector, then it also contains a 0-selector.Hence, we need to show that either Γ ∗ contains a selector, or it contains an XOR function. If φ0(0, . . . , 0) (cid:11)=(cid:6)x1(cid:7)P (1) < Φφ0(1, . . . , 1) then the unary function σ (x) = φ0(x, . . . , x) in Γ ∗ is clearly a selector, and the result holds.Otherwise, we construct the instance P (cid:10) ∈ VCSP(Γ ) with two variables {x0, x1} and the single constraint(cid:6)x0(cid:7)P (cid:10)(cid:6)(cid:6)xr[1], . . . , xr[m](cid:7), φ0(cid:7). Now, by considering the costs of all four possible assignments, we can verify that either Φor Φis either an XOR function, or a NEQ function.is a selector, or else ν = Φ(cid:6)x0,x1(cid:7)P (cid:10)(cid:6)x1(cid:7)P (cid:10)If ν is an XOR function we are done, otherwise we appeal to Lemma 7.4 to complete the proof. (cid:2)Many of the remaining lemmas in this section use the following construction which combines a given function φof arbitrary arity with a pair of selectors, in order to express a binary function with some similar properties.Construction 7.6. Let φ : Dm → R+ be an m-ary function which is not identically infinite, and let σ0 be a 0-selectorand σ1 a 1-selector. Let u, v be two m-tuples, and let M be a natural number larger than all finite values in the rangeof φ.Let P be a VCSP instance with variables {x00, x01, x10, x11}, and constraints:(cid:8)(cid:9)(cid:9)(cid:9)(cid:8)(cid:8)(cid:6)xu[1]v[1], . . . , xu[m]v[m](cid:7), φ,(cid:6)x00(cid:7), Mσ0,(cid:6)x11(cid:7), Mσ1.The binary function φ2def= Φ(cid:6)x01,x10(cid:7)Pwill be called a compression of φ by u and v.Lemma 7.7. Let Γ be a valued Boolean constraint language with costs in R+ which is not essentially crisp, and doesnot have any of the multimorphisms (cid:6)0(cid:7) or (cid:6)1(cid:7) or (cid:6)Max, Max(cid:7) or (cid:6)Min, Min(cid:7).Either Γ ∗ contains a finite 0-selector and a finite 1-selector, or else Γ ∗ contains an XOR function.Proof. Let φ be a function in Γ which does not have a (cid:6)Max, Max(cid:7) multimorphism, and let ψ be a function in Γwhich does not have a (cid:6)Min, Min(cid:7) multimorphism.By Lemma 7.5, either Γ ∗ contains an XOR function and we have nothing to prove, or else Γ ∗ contains a 0-selector,σ0, and a 1-selector, σ1.Since φ does not have a (cid:6)Max, Max(cid:7) multimorphism, it follows from Lemma 6.14 that either φ is not finitelyantitone, or else the relation Feas(φ) does not have the polymorphism Max.For the first case, choose two tuples u and v, with u < v with φ(u) < φ(v) < ∞, and let φ2 be a compression ofφ by u and v (see Construction 7.6). It is straightforward to check that φ2(0, 0) < φ2(1, 1) < ∞, which means thatφ2(x, x) is a finite 0-selector belonging to Γ ∗.On the other hand suppose that φ is finitely antitone, and that Γ ∗ contains a finite 1-selector τ . In this case weknow that Feas(φ) does not have the polymorphism Max, so we can choose u, v such that φ(u), φ(v) < ∞ andφ(Max(u, v)) = ∞. Let φ2 be a compression of φ by u and v, and construct the instance P ∈ VCSP Γ ∗ with variables{x, y}, and constraints:(cid:6)x, y(cid:7), φ2(cid:6)y, x(cid:7), φ2(cid:6)y(cid:7), τ,,.(cid:9)(cid:9)(cid:8)(cid:9)(cid:8)(cid:8)The fact that φ is finitely antitone gives φ(u), φ(v) (cid:2) φ(Min(u, v)). This, together with the fact that φ(u) and φ(v)are finite whilst φ(Max(u, v)) is infinite, is enough to show that Φ(cid:6)x(cid:7)P is a finite 0-selector.1010D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016So, we have shown that if Γ ∗ contains a finite 1-selector, then it contains a finite 0-selector whether or not φ isfinitely antitone. A symmetric argument, exchanging 0 and 1, Max and Min, and φ and ψ, shows that if Γ ∗ containsa finite 0-selector, then it contains a finite 1-selector.Hence, to complete the proof we may assume that Γ ∗ contains no finite selectors. In this case we know thatFeas(φ) does not have the polymorphism Max and Feas(ψ) does not have the polymorphism Min, so we may choosetuples u, v, w, z such that φ(u), φ(v), ψ(w) and ψ(z) are all finite, but φ(Max(u, v)) and ψ(Min(w, z)) are bothinfinite. Now let φ2 be a compression of φ by u and v, and ψ2 a compression of ψ by w and z We then have thatρ(x, y) def= φ2(x, y) + φ2(y, x) + ψ2(x, y) + ψ2(y, x) is a NEQ function which is contained in Γ ∗. We can now appealto Lemma 7.4 to show that Γ ∗ contains an XOR function, and we are done. (cid:2)Lemma 7.8. Let Γ be a valued Boolean constraint language with costs in R+ which does not have the multimorphism(cid:6)Min, Max(cid:7).If Γ ∗ contains both a finite 0-selector and a finite 1-selector, then Γ ∗ contains a NEQ function or an XOR function.Proof. Let φ be a function in Γ that does not have the multimorphism (cid:6)Min, Max(cid:7). Choose u, v such thatφ(Min(u, v)) + φ(Max(u, v)) > φ(u) + φ(v). Let φ2 be a compression of φ by u and v. It is straightforward tocheck that the binary function φ2 also does not have the multimorphism (cid:6)Min, Max(cid:7).It follows thatφ2(0, 0) + φ2(1, 1) > φ2(0, 1) + φ2(1, 0).(14)Without loss of generality, suppose that φ2(0, 0) (cid:3) φ2(1, 1). (The proof for the case φ2(0, 0) > φ2(1, 1) is symmetri-cally equivalent.)From Eq. (14), we have2φ2(0, 0) −(cid:22)(cid:21)φ2(0, 1) + φ2(1, 0)(cid:22)(cid:21)φ2(0, 1) + φ2(1, 0)>− 2φ2(1, 1)with 2φ2(0, 0) − [φ2(0, 1) + φ2(1, 0)] > 0.negative rational number NM such thatNow let σ0 ∈ Γ ∗ be a finite 0-selector, and set λ = σ0(1) − σ0(0). Since λ > 0, it is possible to choose a non-2φ2(0, 0) −(cid:22)(cid:21)φ2(0, 1) + φ2(1, 0)>NM(cid:21)(cid:22)φ2(0, 1) + φ2(1, 0)λ >− 2φ2(1, 1).Construct an instance P ∈ VCSP (Γ ∗) with variables {x, u, v, y}, and constraints(cid:9)(cid:9)(cid:8)(cid:8),(cid:9),(cid:9),(cid:8)(cid:6)x, u(cid:7), Mφ2(cid:8)(cid:6)u, v(cid:7), Mφ2(cid:6)v, y(cid:7), Mφ2(cid:8)(cid:6)x(cid:7), N σ0,(cid:9)(cid:6)v(cid:7), 2N σ0,(cid:9)(cid:8),(cid:9),(cid:9),(cid:8)(cid:6)u, x(cid:7), Mφ2(cid:6)v, u(cid:7), Mφ2(cid:8)(cid:6)y, v(cid:7), Mφ2(cid:9)(cid:8)(cid:6)u(cid:7), 2Nσ0,(cid:9)(cid:6)y(cid:7), N σ0.(cid:8)If we set W = (cid:6)x, y(cid:7), and η = ΦWP , then it is straightforward to verify that η(0, 1) = η(1, 0), η(0, 0) = η(1, 1), and(cid:10)2φ2(0, 0) −(cid:21)(cid:22)φ2(0, 1) + φ2(1, 0)(cid:22)(cid:21)φ2(0, 1) + φ2(1, 0)η(0, 0) = η(0, 1) + M min(cid:25)− 2φ2(1, 1)λ −λ,− NMNM> η(0, 1).If φ2(1, 1) = ∞, then η(0, 0) = ∞ and hence η is a NEQ function. If φ2(1, 1) < ∞, then η(0, 0) < ∞ and hence η isan XOR function. (cid:2)Lemma 7.9. Let Γ be a valued Boolean constraint language with costs in R+ which does not have the multimorphism(cid:6)Mjrty, Mjrty, Mnrty(cid:7).If Γ ∗ contains a finite 0-selector, a finite 1-selector, and a NEQ function, then Γ ∗ contains an XOR function.D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10161011Proof. Suppose that σ0 ∈ Γ ∗ is a finite 0-selector, σ1 ∈ Γ ∗ is a finite 1-selector, ν ∈ Γ ∗ is a NEQ function, and φ ∈ Γdoes not have the multimorphism (cid:6)Mjrty, Mjrty, Mnrty(cid:7). We have to show that Γ ∗ also contains an XOR function.By Corollary 6.26 there are 2 cases: either φ is not finitely modular, or Feas(φ) does not have both polymorphismsMjrty and Mnrty.In the first case, choose tuples u, v such that φ(u) + φ(v) (cid:11)= φ(Min(u, v)) + φ(Max(u, v)). Let φ2 be a compressionof φ by u and v. It is straightforward to check that φ2 is also not finitely modular. Now construct the instance P withvariables {w, x, y, z}, and constraints(cid:8)(cid:9)(cid:8)(cid:9)(cid:8)(cid:6)x, w(cid:7), ν,(cid:6)z, y(cid:7), ν,(cid:8)(cid:9)(cid:6)w, y(cid:7), φ2.It is straightforward to check that either Φor Φ(cid:6)w,y(cid:7)Pis an XOR function.(cid:9),(cid:6)x, z(cid:7), φ2(cid:6)x,y(cid:7)PNext, suppose that Feas(φ) has the polymorphism Mjrty but not Mnrty. In this case, by Theorem 3.5 of [25],Feas(φ) is decomposable into binary relations (in other words, it is equal to the relational join of its binary projections).Since Feas(φ) does not have the Mnrty polymorphism, this implies that one of its binary projections does not have theMnrty polymorphism. The only binary Boolean relations which do not have the Mnrty polymorphism have exactlythree tuples. Therefore, by projection, it is possible to construct from φ a binary function ψ such that exactly three ofψ(0, 0), ψ(0, 1), ψ(1, 0), ψ(1, 1) are finite. If ψ(0, 1) or ψ(1, 0) is infinite, then let η be the projection onto variablesx, y of ψ(x, v) + ν(v, y), otherwise let η = ψ. The function η does not have the multimorphism (cid:6)Min, Max(cid:7), andexactly one of η(0, 0) and η(1, 1) are infinite, and so, by the construction in the proof of Lemma 7.8, Γ ∗ contains anXOR function.Suppose now that Feas(φ) has the polymorphism Mnrty but not Mjrty. Since Feas(φ) has the polymorphismMnrty, it is an affine relation [10] over the finite field with 2 elements, GF(2), and can be expressed as a system oflinear equations over GF(2). Creignou et al. define a Boolean relation to be affine with width 2 if it can be expressedas a system of linear equations over GF(2), with at most two variables per equation [10]. In fact, linear equationsover GF(2) with one variable correspond to the unary relations, and linear equations over GF(2) with two variablescorrespond to the binary equality and disequality relations. The unary relations, and the binary equality and disequalityrelations all have both the Mjrty and Mnrty polymorphisms. Thus Feas(φ) is affine but not of width 2. Hence, byLemma 5.34 of [10], Feas(φ) can be used to construct the 4-ary affine constraint w + x + y + z = 0. In other words,there is some ψ ∈ Γ ∗ such that ψ(w, x, y, z) < ∞ iff w + x + y + z = 0.Now set λ = ψ(0, 0, 1, 1) + ψ(0, 1, 0, 1) + 1 and construct the VCSP instance P with variables {w, x, y, z}, andconstraints(cid:8)(cid:6)w, x, y, z(cid:7), ψ(cid:9),(cid:8)(cid:6)w(cid:7), 3Mσ0(cid:9),(cid:8)(cid:6)z(cid:7), λσ1(cid:9)where M is a natural number larger than the square of any finite value in the range of ψ or σ1. Let η = Φ. Itis straightforward to verify that η is a binary function where both η(0, 0) and η(1, 1) are finite, and it does not havethe multimorphism (cid:6)Min, Max(cid:7). Hence, by the construction in the proof of Lemma 7.8, the result follows in this casealso.Finally, if Feas(φ) has neither the polymorphism Mnrty nor Mjrty, then the set of Boolean relations {Feas(φ),Feas(ν)} can be shown to have essentially unary polymorphisms only (see Theorem 4.12 of [24]). By Theorem 4.10of [24], this implies that in this case Feas(φ) can again be used to construct the 4-ary affine constraint w + x + y + z =0, and we can proceed as above. (cid:2)(cid:6)x,y(cid:7)PLemma 7.10. Let Γ be a valued Boolean constraint language with costs in R+ which does not have any of themultimorphisms listed in Theorem 7.1.Either Γ is essentially crisp, or else Γ ∗ contains an XOR function.Proof. Suppose that Γ is not essentially crisp and has none of the multimorphisms listed in Theorem 7.1. By Lem-mas 7.8 and 7.7, either Γ ∗ contains an XOR function, or else Γ ∗ contains a NEQ function and a finite 0-selector anda finite 1-selector. In the latter case, by Lemma 7.9 we know that Γ ∗ contains an XOR function. (cid:2)Combining Lemmas 7.2 and 7.10, together with Proposition 5.1, establishes the NP-hardness of any valued Booleanconstraint language having none of the multimorphisms listed in Theorem 7.1, and so completes the proof of Theo-rem 7.1.1012D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016For valued Boolean constraint languages taking finite values only, some of the tractable cases identified in Theo-rem 7.1 coincide, as the next result indicates.Corollary 7.11. Let Γ be a valued Boolean constraint language where all costs are finite real values. If Γ has one ofthe multimorphisms (cid:6)0(cid:7), (cid:6)1(cid:7), or (cid:6)Min, Max(cid:7), then VCSP(Γ ) is tractable. In all other cases VCSP(Γ ) is NP-hard.Proof. Let φ be a function taking finite values in R+ only. By Lemma 6.14, if φ has the multimorphism (cid:6)Max, Max(cid:7),then φ is antitone, and hence has the multimorphism (cid:6)1(cid:7). By a symmetric argument, if φ has the multimorphism(cid:6)Min, Min(cid:7), then φ is monotone, and hence has the multimorphism (cid:6)0(cid:7). By Proposition 6.20, if φ has the multimor-phism (cid:6)Mjrty, Mjrty, Mjrty(cid:7), then φ is constant, and hence has the multimorphism (cid:6)0(cid:7). Similarly, by Proposition 6.22,if φ has the multimorphism (cid:6)Mnrty, Mnrty, Mnrty(cid:7), then φ is again constant, and hence has the multimorphism (cid:6)0(cid:7).By Corollary 6.26, if φ has the multimorphism (cid:6)Mjrty, Mjrty, Mnrty(cid:7), then φ is modular, and hence it has the multi-morphism (cid:6)Min, Max(cid:7). The result now follows from Theorem 7.1. (cid:2)We now show that Theorem 7.1 generalises a number of earlier dichotomy results for particular Boolean prob-lems [10,30,42]. Let S be a set of Boolean relations: the problem SAT(S) is the problem of deciding whether thereexists an assignment s : V → {0, 1} which satisfies a given collection of crisp constraints with relations chosen from S.The problem MAX-SAT(S) is the problem of finding an assignment which maximises the number of constraints fromsuch a collection which are simultaneously satisfied. The problem MIN-ONES(S) is the problem of deciding whetherthere exists an assignment which satisfies a given collection of crisp constraints with relations chosen from S, and if sofinding such an assignment which minimises the number of variables taking the value 1. In the slightly more generalweighted MIN-ONES(S) problem the aim is to minimise a specified weighted sum,v∈V wvs(v), where the wv arenon-negative integers [10,30]. Similarly, the problem MAX-ONES(S) is the problem of deciding whether there existsan assignment which satisfies a given collection of crisp constraints with relations chosen from S, and if so findingsuch an assignment which maximises the number of variables taking the value 1. In the weighted MAX-ONES(S)(cid:18)v∈V wvs(v), where the wv are non-negative integers [10,problem the aim is to maximise a specified weighted sum,30].(cid:18)Corollary 7.12. Let S be a set of Boolean relations and let ΓS = {φR | R ∈ S} be the corresponding crisp valuedconstraint language over {0, 1}.1. SAT(S) can be solved in polynomial time if S has one of the polymorphisms 0, 1, Min, Max, Mnrty, or Mjrty.Otherwise it is NP-complete.2. MAX-SAT(S) can be solved in polynomial time if ΓS has one of the multimorphisms (cid:6)0(cid:7), (cid:6)1(cid:7), or (cid:6)Min, Max(cid:7).Otherwise it is NP-hard.3. Weighted MIN-ONES(S) can be solved in polynomial time if ΓS has one of the multimorphisms (cid:6)0(cid:7), (cid:6)Min, Min(cid:7),or (cid:6)Mjrty, Mjrty, Mnrty(cid:7). Otherwise it is NP-hard.4. Weighted MAX-ONES(S) can be solved in polynomial time if ΓS has one of the multimorphisms (cid:6)1(cid:7), (cid:6)Max, Max(cid:7),or (cid:6)Mjrty, Mjrty, Mnrty(cid:7). Otherwise it is NP-hard.Proof. 1. Follows immediately from Theorem 7.1 and Proposition 4.10.2. Follows from Corollary 7.11 and Example 2.9.3. Let φ1 : {0, 1} → R+ be the function defined by φ1(x) = x. By Example 3.3, the problem VCSP({φ1}) is equiv-v∈V wvs(v), where the wv are non-negativealent to the problem of minimising a linear expression of the formintegers. Hence, weighted MIN-ONES(S) can be expressed as VCSP(ΓS ∪ {φ1}). The function φ1 is contained inexactly 4 of the tractable classes identified in Theorem 7.1 (cases 1, 4, 5 and 8), so the problem VCSP(ΓS ∪ {φ1}) istractable when ΓS has one of the multimorphisms (cid:6)0(cid:7), (cid:6)Min, Min(cid:7), (cid:6)Min, Max(cid:7), or (cid:6)Mjrty, Mjrty, Mnrty(cid:7), and NP-hard otherwise. Finally, by Proposition 4.10, if a crisp language has the multimorphism (cid:6)Min, Max(cid:7) then it also hasthe multimorphism (cid:6)Min, Min(cid:7).(cid:18)4. Similar to (3), but using the function φ(cid:10)1 defined by φ(cid:10)1(x) = 1 − x. (cid:2)D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10161013Corollary 7.12 gives an alternative and more unified description of the tractable cases for these problems to theones given previously in [10,30,42].Finally, we note that the dichotomy described in Theorem 7.1 can be expressed in a more concise form using earlierresults about crisp Boolean constraints and Theorem 5.4.Corollary 7.13. Let Γ be a valued Boolean constraint language with costs in R+. If Γ has a non-trivial multimor-phism then it is tractable. Otherwise it is NP-hard.Proof. Earlier results about crisp Boolean constraint languages show that a crisp Boolean language is tractable ifit has a polymorphism which is not essentially unary, and NP-complete otherwise (see, for example, Corollary 2.29of [6]). Using the relationship between polymorphisms and multimorphisms set out in Proposition 4.10, and the factthat multimorphisms are preserved by addition of a constant, this implies that the result holds when Γ is essentiallycrisp.If Γ is not essentially crisp, then by Lemma 7.10, either Γ has a non-trivial multimorphism, and is tractable forone of the reasons described earlier, or else Γ ∗ contains an XOR function.If Γ ∗ contains an XOR function, then by Corollary 5.5, every multimorphism of Γ is trivial. (cid:2)8. Conclusions and future workIn this paper we have begun a systematic investigation of the complexity of the optimisation problems resultingfrom different forms of soft constraint. Since soft constraints are specified by functions, we have introduced an alge-braic property of a function, which we call a multimorphism, and shown that in a range of cases the presence of sucha property is sufficient to ensure tractability.Moreover, we have shown that the presence of a multimorphism precisely characterises a number of tractable prob-lem classes that appear on the surface to be very different. These tractable classes are listed in Section 6; as indicatedby the examples given in that section, they are overlapping, but incomparable, in the sense that none is contained inany of the others (see Fig. 2). In the Boolean case, when the costs are real-valued or infinite, we have shown thatthe presence of one of eight forms of multimorphism characterises each of the possible tractable cases, and that allother cases are NP-hard. This result generalises earlier complexity classifications for the SATISFIABILITY, MAX-SAT,MIN-ONES and MAX-ONES problems.On the basis of the results presented here, we conjecture that the multimorphisms of a valued constraint languageover a finite set completely determine its expressive power, and hence its complexity. If this is true, then multimor-Fig. 2. The tractable classes identified in Section 6.1014D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016phisms are likely to play a central role in the analysis of complexity for soft constraints, just as the related notion of apolymorphism does in the analysis of complexity for crisp constraints [4–6,26–28].To define any form of soft constraint we must specify the set of possible values for the costs, and the way in whichthese are combined. In this paper we have adopted the valued constraint framework [1,43], where the costs are chosenfrom some totally ordered set. For our concrete classification results in Sections 5, 6 and 7 we have fixed this set tobe R+, the set of non-negative real numbers together with infinity, combined using standard addition. One possibledirection in which to extend our results would be to investigate the complexity of valued constraint languages withother valuation structures.Example 8.1. Consider the set of integers {0, 1, . . . , M} for some fixed M (cid:3) 1. We can define a valuation structure,ΩM , on this set by taking the standard ordering, and defining the aggregation operation to be the addition-with-ceilingoperation +M , defined as follows:∀a, b ∈ {0, 1, . . . , M}a +M b = min{a + b, M}.This valuation structure has been shown to be useful to express problems where all solutions which violate M or moreconstraints are considered equally bad [35].Changing the valuation structure can change the set of multimorphisms associated with a set of functions, as thenext example indicates.Example 8.2. Let Γ be a valued constraint language over a finite set D containing all unary cost functions with range{0, 1}. For each d ∈ D, Γ contains the unary cost function χd , defined as follows:χd (x) =(cid:7)1 if x = d,0 otherwise.Hence if F : Dk → Dk is a multimorphism of Γ , then∀x1, . . . , xk ∈ D,(cid:4)(cid:5)F (x1, . . . , xk)[i]χd(cid:2)k(cid:3)i=1k(cid:3)i=1χd (xi).(15)It was shown in Lemma 4.9 that every conservative function is a multimorphism of Γ . If the costs taken by thefunctions in Γ are defined to be elements of R+, then the converse result also holds: every multimorphism of Γ isconservative. To see this, note that in this case Eq. (15) implies that for each d ∈ D, the k-tuple F (x1, . . . , xk) containsat most as many coordinate positions equal to d as the tuple (cid:6)x1, . . . , xk(cid:7). Since this is true for each d ∈ D, it followsthat we have equality for each d ∈ D, which means that F is conservative.However, if the costs are defined to be elements of the valuation structure ΩM defined in Example 8.1 then thisargument no longer holds when k > M. For example, when M = 1, Γ is the language containing all crisp unary costfunctions, which has the multimorphism (cid:6)Max, Max(cid:7), which is not conservative.Another possible extension of the results obtained here would be to allow the costs to be chosen from a partiallyordered set. This additional flexibility is allowed by the semiring-based framework for soft constraints [1,2]. Thisframework also allows for other operations to be used in defining what constitutes the preferred cost, rather thansimply the minimum. Further investigation is needed to determine whether the notion of a multimorphism can be usedto characterise interesting tractable constraint languages in this more general framework.Other future developments to this work could include the study of approximability properties for optimisation prob-lems involving soft constraints over arbitrary finite sets. This would build on and extend the detailed and successfulinvestigation of approximability properties which has already been completed for MAX-SAT and related problems inthe Boolean case [10,30].References[1] S. Bistarelli, H. Fargier, U. Montanari, F. Rossi, T. Schiex, G. Verfaillie, Semiring-based CSPs and valued CSPs: Frameworks, properties, andcomparison, Constraints 4 (1999) 199–240.D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–10161015[2] S. Bistarelli, U. Montanari, F. Rossi, Constraint solving over semirings, in: Proceedings of the 14th International Joint Conference on ArtificialIntelligence (IJCAI’95), Montreal, Canada, 1995, pp. 624–630.[3] E. Boros, P.L. Hammer, Pseudo-boolean optimization, Discrete Applied Mathematics 123 (2002) 155–225.[4] A.A. Bulatov, A dichotomy theorem for constraint satisfaction problems on a 3-element set, Journal of the ACM 53 (2006) 66–120.[5] A.A. Bulatov, A.A. Krokhin, P.G. Jeavons, The complexity of maximal constraint languages, in: Proceedings 33rd ACM Symposium onTheory of Computing, STOC’01, 2001, pp. 667–674.[6] A.A. Bulatov, P.G. Jeavons, A.A. Krokhin, Classifying the complexity of constraints using finite algebras, SIAM Journal on Computing 34(2005) 720–742.[7] D. Cohen, M. Cooper, P. Jeavons, A. Krokhin, A maximal tractable class of soft constraints, Journal of Artificial Intelligence Research 22(2004) 1–22.[8] M.C. Cooper, D.A. Cohen, P.G. Jeavons, Characterising tractable constraints, Artificial Intelligence 65 (1994) 347–361.[9] N. Creignou, A dichotomy theorem for maximum generalized satisfiability problems, Journal of Computer and System Sciences 51 (1995)511–522.[10] N. Creignou, S. Khanna, M. Sudan, Complexity Classification of Boolean Constraint Satisfaction Problems, SIAM Monographs on DiscreteMathematics and Applications, vol. 7, Society for Industrial and Applied Mathematics, 2001.[11] W.H. Cunningham, Minimum cuts, modular functions, and matroid polyhedra, Networks 15 (2) (1985) 205–215.[12] E. Dahlhaus, D.S. Johnson, C.H. Papadimitriou, P.D. Seymour, M. Yannakakis, The complexity of multiterminal cuts, SIAM Journal onComputing 23 (4) (1994) 864–894.[13] V. Dalmau, Generalized majority–minority operations are tractable, in: Proceedings 20th IEEE Symposium on Logic in Computer Science(LICS 2005), IEEE Computer Society, 2005, pp. 438–447.[14] R. Dechter, Constraint Processing, Morgan Kaufmann, 2003.[15] T. Feder, M.Y. Vardi, The computational structure of monotone monadic SNP and constraint satisfaction: A study through Datalog and grouptheory, SIAM Journal on Computing 28 (1998) 57–104.[16] L. Fleischer, S. Iwata, Improved algorithms for submodular function minimization and submodular flow, in: Proceedings of the 32th AnnualACM Symposium on Theory of Computing, 2000, pp. 107–116.[17] E.C. Freuder, R. Wallace, Partial constraint satisfaction, Artificial Intelligence 58 (1992) 21–70.[18] S. Fujishige, S. Iwata, Bisubmodular function minimization, in: Integer Programming and Combinatorial Optimization: 8th International IPCOConference, in: Lecture Notes in Computer Science, vol. 2081, Springer, Berlin, 2001, pp. 160–169.[19] M. Garey, D.S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, Freeman, San Francisco, CA, 1979.[20] M. Grötschel, L. Lovasz, A. Schrijver, The ellipsoid method and its consequences in combinatorial optimization, Combinatorica 1 (1981)169–198.[21] G. Gutin, A. Rafiey, A. Yeo, Minimum cost and list homomorphisms to semicomplete digraphs, Discrete Applied Mathematics 154 (2006)890–897.[22] G. Gutin, A. Rafiey, A. Yeo, Level of repair analysis and minimum cost homomorphisms of graphs, Discrete Applied Mathematics 154 (2006)881–889.[23] S. Iwata, L. Fleischer, S. Fujishige, A combinatorial strongly polynomial algorithm for minimizing submodular functions, Journal of theACM 48 (4) (2001) 761–777.[24] P.G. Jeavons, On the algebraic structure of combinatorial problems, Theoretical Computer Science 200 (1998) 185–204.[25] P.G. Jeavons, D.A. Cohen, M.C. Cooper, Constraints, consistency and closure, Artificial Intelligence 101 (1–2) (1998) 251–265.[26] P.G. Jeavons, D.A. Cohen, M. Gyssens, Closure properties of constraints, Journal of the ACM 44 (1997) 527–548.[27] P.G. Jeavons, D.A. Cohen, M. Gyssens, How to determine the expressive power of constraints, Constraints 4 (1999) 113–131.[28] P.G. Jeavons, D.A. Cohen, J.K. Pearson, Constraints and universal algebra, Annals of Mathematics and Artificial Intelligence 24 (1998) 51–67.[29] P.G. Jeavons, M.C. Cooper, Tractable constraints on ordered domains, Artificial Intelligence 79 (2) (1995) 327–339.[30] S. Khanna, M. Sudan, L. Trevisan, D. Williamson, The approximability of constraint satisfaction problems, SIAM Journal on Computing 30 (6)(2001) 1863–1920.[31] L. Khatib, P.H. Morris, R.A. Morris, F. Rossi, Temporal constraint reasoning with preferences, in: Proceedings of the 17th International JointConference on Artificial Intelligence (IJCAI-01), Seattle, US, 2001, pp. 322–327.[32] L. Kirousis, Fast parallel constraint satisfaction, Artificial Intelligence 64 (1993) 147–160.[33] A. Krokhin, A. Bulatov, P. Jeavons, The complexity of constraint satisfaction: An algebraic approach, in: Proceedings of the NATO AdvancedStudy Institute on Structural Theory of Automata, Semigroups and Universal Algebra, in: NATO Science Series II: Mathematics, Physics andChemistry, vol. 207, Springer, Berlin, 2005, pp. 181–213.[34] J. Larrosa, P. Meseguer, T. Schiex, Maintaining reversible DAC for Max-CSP, Artificial Intelligence 107 (1999) 149–163.[35] J. Larrosa, T. Schiex, Solving weighted CSP by maintaining arc consistency, Artificial Intelligence 159 (2004) 1–26.[36] A.K. Mackworth, E.C. Freuder, The complexity of constraint satisfaction revisited, Artificial Intelligence 59 (1993) 57–62.[37] R. Mohr, G. Masini, Good old discrete relaxation, in: Y. Kodratoff (Ed.), Proceedings 8th European Conference on Artificial Intelligence—ECAI’88, Pitman, 1988, pp. 651–656.[38] U. Montanari, Networks of constraints: Fundamental properties and applications to picture processing, Information Sciences 7 (1974) 95–132.[39] G.L. Nemhauser, L.A. Wolsey, Integer and Combinatorial Optimization, John Wiley & Sons, 1988.[40] J.K. Pearson, P.G. Jeavons, A survey of tractable constraint satisfaction problems, Technical Report CSD-TR-97-15, Royal Holloway, Univer-sity of London, July 1997.[41] R. Pöschel, L.A. Kalužnin, Funktionen- und Relationenalgebren, DVW, Berlin, 1979.[42] T.J. Schaefer, The complexity of satisfiability problems, in: Proceedings 10th ACM Symposium on Theory of Computing, STOC’78, 1978,pp. 216–226.1016D.A. Cohen et al. / Artificial Intelligence 170 (2006) 983–1016[43] T. Schiex, H. Fargier, G. Verfaillie, Valued constraint satisfaction problems: hard and easy problems, in: Proceedings of the 14th InternationalJoint Conference on Artificial Intelligence (IJCAI’95), Montreal, Canada, 1995, pp. 631–637.[44] A. Schrijver, A combinatorial algorithm minimizing submodular functions in strongly polynomial time, JCTB: Journal of CombinatorialTheory, Series B 80 (2000) 346–355.[45] A. Schrijver, Combinatorial Optimization: Polyhedra and Efficiency, Algorithms and Combinatorics, vol. 24, Springer, Berlin, 2003.[46] A. Szendrei, Clones in Universal Algebra, Seminaires de Mathematiques Superieures, vol. 99, University of Montreal, Montreal, 1986.[47] P. van Hentenryck, Y. Deville, A generic arc-consistency algorithm and its specializations, Artificial Intelligence 57 (1992) 291–321.